%===============================================================================
% RH: revised for Pacific Ocean Perch 5ABC (2017-06-06)
% RH: Modified for 5ABC POP to save current objects to help build the final appendix F (2017-04-03)
% RH: Modified for Rock Sole (1 sex) and Silvergray Rockfish (2013-10-01)
% AME: Adding in formatting for resDocSty.sty, from master.tex (2012-08-24).
% From Rowan's run-masterMCMC-rh14aug12.Snw. 
% ymrrun-masterMCMC.Snw - just doing MCMC output (MCMC lines were 
%  commented out in ymrrun-masterMCMC.Snw). AME, 3rd May 2011
% ymrrun5-0.Snw. 5/4/11.
% ymrrun2-5.Snw - from Rowan's run2 output. Fifth reweighting. Also
%  adding in automatic table of parameter values. 28th March 2011
% ymrrun1dos.Snw - automatically plot MPD output from Awatea, using
%  scape. Awatea results.dat file must be in directory above, this
%  one used just for figures. 23rd Feburary 2011
%===============================================================================
% Wish List
%  Re-organise to have all inputting and re-arranging at the start,
%   and do for run-master.Snw also.
%===============================================================================

% From resDoc master.tex:
\documentclass[11pt]{book}   
\usepackage{Sweave}    % Andy added (needs to come before resDocSty)
\usepackage{resDocSty} % Res Doc .sty file
\captionsetup{figurewithin=none,tablewithin=none} %RH: This works for resetting figure and table numbers for book class though I don't know why. Set fig/table start number to n-1.
\usepackage{graphicx}
% \usepackage{epsfig}  % in .sty file
\usepackage{rotating}  % for sideways table
\usepackage{longtable}

%\newcommand{\popQCS}{Edwards-etal:2012pop}
%\newcommand{\ymr}{Edwards-etal:2012ymr}
%\newcommand{\area}{3CD}    % NOT automated in Sweave, but will
%\newcommand{\other}{5DE}   %  be set in master latex file.
%\newcommand{\otherCite}{Edwards-etal:20135DE}

% \newcommand{\eb}{\begin{eqnarray}}
% \newcommand{\ee}{\end{eqnarray}}
% \renewcommand{\baselinestretch}{1.0}
\newcommand{\Bmsy}{B_\mathrm{MSY}}
\newcommand{\umsy}{u_\mathrm{MSY}}
\newcommand{\super}[1]{$^\mathrm{#1}$}

% For write up
%\def\AppLet{G}                   % Appendix letter
%\renewcommand{\theequation}{\AppLet.\arabic{equation}}
%\renewcommand{\thefigure}{\AppLet.\arabic{figure}}
\def\startP{1}                   % page start (default=1)
\def\startF{0}                   % figure start counter (default=0)
\def\startT{0}                   % table start counter (default=0)
\def\bfTh{{\bf \Theta}}  % bold Theta

%\renewcommand{\rmdefault}{phv}   % Arial -- already defined by resDocSty.sty
%\renewcommand{\sfdefault}{phv}   % Arial -- already defined by resDocSty.sty

\newcommand{\ptype}{@ptype} %% png files also available for smaller-sized appendix

% You may give the parameter [!p] to place them on a special float page without any text. Didn't solve everything though. 
% Apparently shouldn't have just one argument.
\newcommand\onefig[2]{  % filename is #1, text is #2
  \begin{figure}[tp]
  \begin{center}
  \includegraphics[width=6.5in,height=7.25in,keepaspectratio=TRUE]{{#1}.\ptype} \\  % RH much better control
  \end{center}
  \caption{#2}
  \label{fig:#1}
  \end{figure}
  \clearpage
}
\newcommand\twofig[3]{  % figure #1 under #2, caption text #3
  \begin{figure}[tp]    %  label will be #1
  \centering
  \begin{tabular}{c}
  \includegraphics[width=6in,height=3.5in,keepaspectratio=TRUE]{{#1}.\ptype} \\  % RH much better control
  \includegraphics[width=6in,height=3.5in,keepaspectratio=TRUE]{{#2}.\ptype}
  \end{tabular}
  \caption{#3}
  \label{fig:#1}
  \end{figure}
  \clearpage
}
\newcommand\threefig[4]{% figure #1 then #2 then #3, 
  \begin{figure}[htp]   %  caption text #4, label will be #1
  \centering
  \begin{tabular}{c}
  \includegraphics[width=6in,height=2.5in,keepaspectratio=TRUE]{{#1}.\ptype} \\  % RH much better control
  \includegraphics[width=6in,height=2.5in,keepaspectratio=TRUE]{{#2}.\ptype} \\
  \includegraphics[width=6in,height=2.5in,keepaspectratio=TRUE]{{#3}.\ptype}
  \end{tabular}
  \caption{#4}
  \label{fig:#1}
  \end{figure}
}

\SweaveOpts{pdf=FALSE}        % keep.source=TRUE, 
% Most useful options (with defaults):
% echo = TRUE  - includes R code in output file
% keep.source = FALSE - when echoing, if TRUE then original source is
%  copied to the file, otherwise deparsed source is echoed.
% eval = TRUE - if FALSE then chunk is not evaluated
% results = verbatim - R output included verbatim, if tex output is 
%  already proper latex and included as is, if hide then all output
%  is completely suppressed (but the code executed - good for admb)
%  Must be lower case (unlike the others!).
% pdf = TRUE - whether .pdf figures shall be generated
% eps = TRUE - whether .eps figures shall be generated
% strip.white = FALSE - if true then blank lines at beginning and
%  end of output are removed. If all, then all blank lines are removed.
% width = 6  - width of figures in inches
% height = 6 - height of figures in inches
% fig = FALSE - whether the code chunk produces graphical output 
%  (only one per chunk)
% \setkeys{Gin}{width=6in}     % from googling sweave figure bigger.
%  It will set this for the rest of document 
%  [doesn't width do that in the above?]

%%==============================================================================
\begin{document}
\setcounter{page}{\startP}
\setcounter{figure}{\startF}
\setcounter{table}{\startT}
\setcounter{secnumdepth}{3}    % To number subsubheadings-ish

\setcounter{chapter}{5}    % for stand-alone chapters (5=E, 6=F)
\renewcommand{\thechapter}{\Alph{chapter}} % ditto
\renewcommand{\thesection}{\thechapter.\arabic{section}}   
\renewcommand{\thesubsection}{\thechapter.\arabic{section}.\arabic{subsection}.}
\renewcommand{\thetable}{\thechapter.\arabic{table}}    
\renewcommand{\thefigure}{\thechapter.\arabic{figure}}  
\renewcommand{\theequation}{\thechapter.\arabic{equation}}
%\renewcommand{\thepage}{\arabic{page}}

\newcounter{prevchapter}
\setcounter{prevchapter}{\value{chapter}}
\addtocounter{prevchapter}{-1}
\newcommand{\eqnchapter}{\Alph{prevchapter}}

%% First set up workspace:
<<setupworkspace, echo=FALSE, results=hide>>= # hide the results 
# get some names created by `runSweave()'
Cnames  = tcall("PBSawatea")$Cnames        # names of commercial gear
CAnames = Cnames[tcall("PBSawatea")$CApos] # names of commercial gear with ages
Snames  = tcall("PBSawatea")$Snames        # names of surveys
SAnames = Snames[tcall("PBSawatea")$SApos] # names of surveys with ages

cwd    = "@cwd"  # Top level directory; all models occur below this one. 
sigdig = 4       # Number of significant digits to output in tables
redo.Graphs = @redo.Graphs  # whether to redo the graphs or not (set to FALSE if just editing the text).
@ 

% '@variables' replaced by function 'runSweave' to create individual Sweaves for runs and reweightings.
<<modelname, echo=FALSE>>=
model.name  = "@model.name"
spp.name    = strsplit(model.name,split="[-\\.]")[[1]][1]
area.name   = strsplit(model.name,split="[-\\.]")[[1]][2]
if (any(spp.name=="ROL")) { # just for Kendra at the moment
	in.area   = if (area.name=="CST") " along the BC coast" else paste(" in Area",area.name)
	for.area  = if (area.name=="CST") " for the BC coast" else paste(" for Area",area.name)
	from.area = if (area.name=="CST") " from the coastwide assessment" else paste(" from the Area",area.name,"assessment")
	catch.type = "estimated female"
} else {
	in.area = for.area = from.area = catch.type = ""
}
run.dir     = "@run.dir"
fig.dir     = "@fig.dir"
mpd.dir     = "@mpd.dir"
msy.dir     = "@msy.dir"
prj.dir     = "@prj.dir"
# running.awatea = @running.awatea   # 0 if just loading previous '.rep'; 1 if rerunning Awatea. 
mcsub       = @mcsub
Nsex        = @nsex
Ngear       = @ngear
resdoc      = @resdoc
@ 

% \pagestyle{myheadings}
% \markright{\Sexpr{paste("From MCMC", model.name, sep="")}}

%###############################################################################
\chapter*{Appendix~\thechapter. MCMC Model Results}

\newcommand{\LH}{DRAFT -- Non-citable working paper}  % Set to {} for final ResDoc
\newcommand{\RH}{CSAP WP 2015GRF08}
\newcommand{\LF}{\Sexpr{paste0("@sppname"," (",area.name,")")}}
\newcommand{\RF}{Appendix~\thechapter ~-- MCMC Model Results}

\lhead{\LH}\rhead{\RH}\lfoot{\LF}\rfoot{\RF}

%\subsection{Area \Sexpr{area.name}}

@rmresdoc \textbf{Paul J. Starr and Rowan Haigh}

@rmresdoc Latest is \today, with \Sexpr{print(version$version.string)}.  % $

@rmresdoc Plotting MCMC output for model {\tt \Sexpr{model.name}}. 

@rmresdoc Graphs ARE \Sexpr{if(!redo.Graphs) paste("NOT")} re-generated during this document build.

Use separate \texttt{Rnw} files for the final chapter integration of MPD and MCMC results and for the write-up.

\section{History of Runs}

\input{\Sexpr{paste(run.dir, "/../runHistory", sep="")}}

@rmresdoc @rmhrp {\bf Note:} Historical reference points have been reported in this document. Output tables typically report $B_\mathrm{Lim}$ (biomass lower limit), $B_\mathrm{Tar}$ (biomass target), and $u_\mathrm{Tar}$ (exploitation rate target). Exploitation rate lower limit ($u_\mathrm{Lim}$) is often not defined.

@rmresdoc \medskip

<<fromscape, results=hide, echo=FALSE>>=
# Commenting some out for ymr.
#--------------------------------------------------------------------#   AME Commands that are actually run.

# Set style of reconstruction-projection plots.
# Options: "lines", "lineDot", "quantBox"
rpType <- "quantBox"

trellis.device(device="postscript", color=TRUE)   # for colour .eps

# Load in .res file.
setwd(fig.dir) 
#currentRes <- importCol2(paste("../", model.name, ".res", sep=""), 
currentRes = importRes(paste(run.dir,"/", model.name, ".res",sep=""),
             Dev=TRUE, CPUE=TRUE, Survey=TRUE, 
             CLc=TRUE, CLs=TRUE, CAs=TRUE, CAc=TRUE, extra=TRUE)
# maybe should be CPUE=cpue

assign("currentRes", currentRes, pos=1)   ## maybe need the assign (maybe because you are jumping from code chunk to code chunk)
save("currentRes",file="currentRes.rda")  ## useful to have when compiling the final results appendix

years = currentRes$B[,"Year"]
sigmaR = currentRes$extra$residuals$p_log_RecDev[6]
    ## to use when importing projected recruitment deviations (that
    ## are actually just the random N(0,1) numbers so need 
    ## multiplying by sigmaR).

# Assign a generic title for use in some plots.
mainTitle <- "@sppname"

# Minimum data year for tuning index.
# minCpueYr <- 1940
#ACH: I'm not sure exactly what this is for but I set it to the start year

# Awatea MCMC.
currentMCMC <- importMCMC( dir=".", quiet=FALSE )
currentMCMC.orig = currentMCMC

#mpd.P = currentMCMC$P[1,]
#mpd.B = currentMCMC$B[1,]
#mpd.R = currentMCMC$R[1,]
#currentMCMC <- sapply(currentMCMC,function(x,s){x[s,]},s=mcsub,simplify=FALSE)
#assign( "currentMCMC", currentMCMC, pos=1 ) # you do need the assign (maybe because you are jumping from code chunk to code chunk)

#num.MCMC = dim(currentMCMC$P)[1]     # number of MCMC samples
# currentMCMCorig = currentMCMC       # to use below
# importMCMC (a scape function) seems to get years wrong on the recruitment, see popScape2.r for details, here is the fix
names(currentMCMC$R) = as.integer(names(currentMCMC$R)) + 1
                                        #currentRes$B$R seems one off
# Also change names of estimated parameters to those matching my
#  write up, and change to the same order. See POPscape2.r .
# **** AME hard-wiring cannot work; RH attempt to fix: ***
#==========================================================
# Get the CPUE, commercial, and survey index series

#CPUE series
Cser=unique(currentRes$CPUE$Series);   Ncpue=NCser=length(Cser)
# There has to be a dummy CPUE series in the input, but the 
#  likelihood switch says whether it is being fitted. Seems
#  that the calculated likelihood is 0 if not fitted:
if(all(currentRes$extra$likelihoods$CPUE==0)) { Ncpue.actual = 0 }
%if(Ncpue > 1) stop("priorInput construction assumes one CPUE series so needs updating in run-masterMCMC.Snw")

# Survey series
Sser = unique(currentRes$Survey$Series)
Sser = Sser[currentRes$extra$likelihoods$Survey_Index!=0]
NSser= length(Sser)

# Get the commercial and survey age series
# These might also need fixing if there are dummy data that aren't being fitted.
CAser=unique(currentRes$CAc$Series);   Ncomm=NCAser=length(CAser)
SAser=unique(currentRes$CAs$Series);   NSAser=length(SAser)

NCOMM = max(Ncpue,Ncomm)  # number of commercial series w/ data/ages
Nsurv = max(NSser,NSAser) # number of survey series with data/ages
GI    = (1:Ngear)+Nsurv # gear indices in model (could have been defined earlier, but tough)

Pnames = names(currentMCMC$P)
# can take out paste once get updated PBSawatea.
new.Pnames = gsub("M1_2",paste("M_",2,sep=""),sub("M1_1",paste("M_",1,sep=""),sub("R0","R_0",Pnames)))
for (i in 1:Ncpue) {
	ii = i + Nsurv
	new.Pnames = sub(paste("log_qCPUE_",i,sep=""),paste("log q_",ii,sep=""),new.Pnames)
}
for (i in 1:Ncomm) {
	ii = i + Nsurv
	new.Pnames = sub(paste("Sfullest_",i,sep=""),paste("mu_",ii,sep=""),new.Pnames)
	new.Pnames = sub(paste("log_varLest_",i,sep=""),paste("log v_",ii,"L",sep=""),new.Pnames)
@rmdome  new.Pnames = sub(paste("log_varRest_",i,sep=""),paste("log v_",ii,"R",sep=""),new.Pnames)
	new.Pnames = sub(paste("Sfulldelta_",i,sep=""),paste("Delta_",ii,sep=""),new.Pnames)
}
for (i in 1:Nsurv) {
	ii = Sser[i]
	new.Pnames = sub(paste("surveySfull_",i,sep=""),paste("mu_",ii,sep=""),new.Pnames)
	new.Pnames = sub(paste("log_surveyvarL_",i,sep=""),paste("log v_",ii,"L",sep=""),new.Pnames)
@rmdome  new.Pnames = sub(paste("log_surveyvarR_",i,sep=""),paste("log v_",ii,"R",sep=""),new.Pnames)
	new.Pnames = sub(paste("surveySfulldeltaest_",i,sep=""),paste("Delta_",ii,sep=""),new.Pnames)
	new.Pnames = sub(paste("log_qsurvey_",i,sep=""),paste("log q_",ii,sep=""),new.Pnames)
}
new.Pnames = sub("log_BetaCPUE","log beta",new.Pnames)
# Probably want to change beta, as have beta in write-up already
#  with respect to SR function. And un-log it. Just another q? Think
#  that's already done above - check when doing on a CPUE one. No,
#  I think it's the power for the CPUE.

# Use this if adding extra parameters that are estimated that
#  we haven't thought of here. This is the global list in the
#  desired order. If >5 surveys then expand this, and expand 
#  priorInput function below. 
# log_q should really go to Nsurv+Ncpue, but will get fixed by
#  use.Pnames.
tab.Pnames = c("R_0","M_1","M_2","h",
  paste("log q_",1:(Nsurv+Ncpue),sep=""),"log beta", 
  paste("mu_",1:(Nsurv+Ncomm),sep=""),
  paste("Delta_",1:(Nsurv+Ncomm),sep=""),
  paste("log v_",1:(Nsurv+Ncomm),"L",sep="")
@rmdome  , paste("log v_",1:(Nsurv+Ncomm),"R",sep="")
  )

# Put them into the standard order:
use.Pnames = tab.Pnames[is.element(tab.Pnames,new.Pnames)]

if(length(use.Pnames) != length(new.Pnames))
  {stop("Check tab.Pnames in run-masterMCMC.Snw")}

# Assign new names
names(currentMCMC$P) = new.Pnames    
# Re-order to match Paul's results table 3:
currentMCMC$P = currentMCMC$P[,use.Pnames]

mpd.P = currentMCMC$P[1,]
mpd.B = currentMCMC$B[1,]
mpd.R = currentMCMC$R[1,]
## Subset MCMC to remove burn-in (e.g., 201:1200)
currentMCMC <- sapply(currentMCMC,function(x,s){x[s,]},s=mcsub,simplify=FALSE)
#assign( "currentMCMC", currentMCMC, pos=1 ) # you do need the assign (maybe because you are jumping from code chunk to code chunk)
num.MCMC = dim(currentMCMC$P)[1]   ## number of MCMC samples

#--- Vulnerable biomass ----------------------------------------------
# Also have to import vulnerable biomass from vulnBiom.pst, as it's
#  not done in importMCMC. Can just do as a data table. Has columns
#  representing years, and each of 1000 rows is an MCMC sample. Same
#  size as currentMCMC$B. It is
#  calculated as denominator of (D.11) in QCS POP model appendix.

vbMCMC = read.table("vulnBiom.pst", header=TRUE)
#names(vbMCMC) = names(currentMCMC$B)      # to make them simply years (only works if Ngear=1)
names(vbMCMC) = paste(rep(names(currentMCMC$B),Ngear),rep(1:Ngear,each=dim(currentMCMC$B)[2]),sep="_") # standardise names to "year_gear"
currentMCMC[["VB"]] = vbMCMC[mcsub,]
  # Add to currentMCMC so that it gets called into functions.
assign( "currentMCMC", currentMCMC, pos=1 ) ## you do need the assign (maybe because you are jumping from code chunk to code chunk)

## currentMCMC is updated with U on L834, UoverUmsy on L874 and BoverBmsy on L879, so save again later on L882
save("currentMCMC",file="currentMCMC.rda")  ## useful to have when compiling the final results appendix
@

\newcommand{\numMCMC}{\Sexpr{prettyNum(num.MCMC, big.mark=",")}}


<<priors, results=hide, echo=FALSE>>=

# Importing and defining prior functions for general model runs.
# If change tab.Pnames above then change some of priorInput.
# Unlogging q's at the end

priorFunc = function(input.prior) 
  { switch(as.character(input.prior[4]),
       "0" = function(x, input.prior) { dunif(x, min =
          input.prior[2], max =  input.prior[3]) },
       "1" = function(x, input.prior) { dnorm(x, mean = input.prior[5], sd = input.prior[6]) },
       "2" = stop("figure out lognormal in priorFunc"),
       "5" = function(x, input.prior) { dbeta(x, shape1 = , input.prior[5], shape2 = input.prior[6]) } )
  }

priorInput = array(dim = c(length(use.Pnames), 7),dimnames=list(use.Pnames,c("Phase","Lower","Upper","Type","Mean","SD","Initial")))
              # array of priors from the input file, going to put
              #  into the order of use.Pnames
priorDistList = list()      # should be length of use.Pnames
for(i in 1:length(use.Pnames)) 
  {
     ii = use.Pnames[i]
     priorInput[i,] =
     switch(ii,
       # This covers all choices in tab.Pnames
        "R_0" = currentRes$extra$priors$R0,
        "M_1" = currentRes$extra$priors$M1_prior[1,],
@rmsex        "M_2" = currentRes$extra$priors$M1_prior[2,],            
        "h"   = currentRes$extra$priors$h_prior,              
#=======Next line will be expanded to accomodate multiple surveys=======
        "log q_1" = currentRes$extra$priors$log_qsurvey_prior[1,],
#=======Next line will be expanded to accomodate multiple CPUE series=======
@rmcpue "log q_999" = currentRes$extra$priors$log_qCPUE_prior[1,],
@rmcpue "log beta" = currentRes$extra$priors$log_BetaCPUE_prior[1,],
#=======Next line will be expanded to accomodate multiple surveys=======
        "mu_1" = currentRes$extra$priors$surveySfull_prior[1,],
#=======Next line will be expanded to accomodate multiple gears=======
        "mu_999" = currentRes$extra$priors$p_Sfullest[1,],
#=======Next line will be expanded to accomodate multiple surveys=======
@rmsex  "Delta_1" = currentRes$extra$priors$p_surveySfulldelta[1,],
#=======Next line will be expanded to accomodate multiple gears=======
@rmsex  "Delta_999" = currentRes$extra$priors$p_Sfulldelta[1,],
#=======Next line will be expanded to accomodate multiple surveys=======
        "log v_1L" = currentRes$extra$priors$log_surveyvarL_prior[1,],
#=======Next line will be expanded to accomodate multiple gears=======
        "log v_999L" = currentRes$extra$priors$log_varLest_prior[1,],
#=======Next line will be expanded to accomodate multiple surveys=======
@rmdome "log v_1R" = currentRes$extra$priors$log_surveyvarR_prior[1,],
#=======Next line will be expanded to accomodate multiple gears=======
@rmdome "log v_999R" = currentRes$extra$priors$log_varRest_prior[1,],
     )
     priorDistList[[i]] = priorFunc(priorInput[i,])
   }
row.names(priorInput) = use.Pnames       
names(priorDistList) = use.Pnames

# confused that after running, those two have q_1 etc. but use.Pnames does not.

# Now going to use q_1, q_2, q_3, not log q_1 etc. So rename and then change values:
qnames = use.Pnames[grep("log q_",use.Pnames)]
for (i in qnames) {
	currentMCMC$P[,i] = exp(currentMCMC$P[,i])
	mpd.P[i] = exp(mpd.P[i])  # exponentiates the MCMC values
}
names(currentMCMC$P)[is.element(names(currentMCMC$P),qnames)] = substring(qnames,5)
names(mpd.P)[is.element(names(mpd.P),qnames)] = substring(qnames,5)

# Don't need to change tab.Pnames etc. as figures get labelled 
#  automatically from the names in currentMCMC$P

# Need to 'exponentiate' the priors and bounds for q
for(i in qnames) {
  if(priorInput[i,4] != 0) stop("need to exponentiate non-uniform priors for log q, in run-masterMCMC.Snw")
  # otherwise it's uniform.
  # Need to have the bounds exponentiated because the panel.curve
      #  plot uses them automatically to define the range. So change
      #  the priorInput bound values here, and change priorDistList 
      #  to use those because that's what will get called.
  priorInput[i,c(2,3,7)] = exp(priorInput[i,c(2,3,7)])   # 7 is init cdtn
  priorDistList[[i]] = function(x, input.prior) 
    {   # log x uniform between a and b, then pdf for x is
        #  1/(x (b-a)) between exp(a) and exp(b). Equivalently
        # A = exp(a), B = exp(b) gives pdf for x as
        # 1 /(x (log(B) - log(A)) between A and B
      (x*( log(input.prior[3]) - log(input.prior[2])))^(-1) * ((x >= input.prior[2]) & (x <= input.prior[3] ) ) }
  }  
# And rename priorInput and priorDistList.
row.names(priorInput)[is.element(row.names(priorInput),qnames)] = substring(qnames,5)
names(priorDistList)[is.element(names(priorDistList),qnames)] = substring(qnames,5)


# AME - I'd thought have to fix for beta also, but that's set to 0 for now
#  I think (had thought it was q, but it's the power).

# End RH fix
#==========================================================
@ % end <<priors>> chunk

<<projections, results=hide, echo=FALSE>>=

# Deleting lots of commented out code, 20th August 2012.

# Awatea projection.
# The importProj function loads a list with elements "B" and "Y" for 
# biomass by catch policy and year, and catch by harvest policy and 
# year.  The "B" element is itself a list of matrices with a matrix 
# for each level of the catch.  This matrix has rows equal to the   
# length of the chain and columns corresponding to projection years.
# There are no [specific - AME] plotting routines for these data.    

# currentProj$eps is a list of data frames, one for each catch
#  strategy, though each data frame is the same (because the same
#  random N(0,1) are used for each one). Each data frame is 1000x91
#  as each row is an MCMC sample and each column is projected year,
#  from 2011 to 2101. For a given MCMC sample, the same random
#  numbers are used for each strategy (but random numbers are
#  different between MCMC samples). i.e.:
# > range(currentProj$eps$'0'[1,] - currentProj$eps$'0'[2,] )
# [1] -2.722770  2.844936
# > range(currentProj$eps$'0'[1,] - currentProj$eps$'250'[1,] )
# [1] 0 0
# So although the eps are the same for each strategy, the actual
#  recruitments won't be because the spawning biomassess will be
#  changing (first year should be the same though).

# currentProj <- importProj( dir=".", quiet=FALSE )

# source("../../importProjRecAndy.r")   # adding VB to importProjRec
currentProj <- importProjRec( dir=prj.dir, ngear=Ngear, quiet=FALSE )  # RH added `ngear' to deal with multiple Virgin VBs
   # importProjRec includes epsilons for recruitments
   # Then below we calcualte the actual recruitments.
   # RH: Note that only one VB series is projected because input file specifies:
   # Gear used in projections (0=read in; 1=use same gear proportions as last year of data)

currentProj <- sapply(currentProj,function(X){sapply(X,function(x,s){x[s,]},s=mcsub,simplify=FALSE)},simplify=FALSE)

## **** COMMENTING THIS OUT TO GET POP 5ABC WORKING
## Rowan, can we put an 'if' statement in to ignore this only for POP 5ABC.
## Take off final year of projection
if (@skip.last.year) { 
	currentProj$B = lapply(currentProj$B, function(x) {  x[ ,1:(dim(x)[[2]]-1)]  })
	currentProj$Y = lapply(currentProj$Y, function(x) { x[ ,1:(dim(x)[[2]]-1)]  })
	currentProj$eps = lapply(currentProj$eps, function(x) {  x[ ,1:(dim(x)[[2]]-1)] })
	currentProj$VB = lapply(currentProj$VB, function(x) {  x[ ,1:(dim(x)[[2]]-1)]  })
}
## **** END ****

# currentProj$R is calculated below
# sd(unlist(currentProj$eps$'0'))
# [1] 0.8993165
#  sd(unlist(currentProjaa$eps$'250'))
# [1] 0.8993165
#  etc., as they're all the same, and the sd equals sigmaR.


# Calculate projected exploitation rates.
currentProj$U = currentProj$VB    # Want the same size

catchProj = names(currentProj$VB)
for(i in catchProj)
  {
  currentProj$U[[i]] = currentProj$Y[[i]] / currentProj$VB[[i]]
}
## So currentProj$U is now exploitation rate for MCMC projections.

# boxplot(currentProj$U[[5]])   to plot
## Note: if go beyond 10 years (or have earlier maturing fish) then
##  for u table need to check that u doesn't go to 0 when stock 
##  extinct. Check  sapply(currentProj$U, min)   only has 0 for 0 
##  catch policy.

assign( "currentProj", currentProj, pos=1 )
save("currentProj",file="currentProj.rda")  ## useful to have when compiling the final results appendix
@ %end <<projections>> chunk

<<MSY, results=hide, echo=FALSE>>=

## Awatea MSY.
currentMSY = msyCalc( dir=msy.dir, error.rep = 0 )  # reports if MSY not converged

## Next line now doesn't work with the scalars in the list, so 
##  replacing with an error for now as we're using all mcsub values
##  for POP 3CD and 5DE.

currentMSY = sapply(currentMSY,function(x,s){x[s]},s=mcsub,simplify=FALSE)  # mcsub subsets the MCMC samples

assign( "currentMSY", currentMSY, pos=1 ) ## Forces it global (or something)
save("currentMSY",file="currentMSY.rda")  ## useful to have when compiling the final results appendix

## Do these for ease of showing statistics in tables. 
## Each should be a vector with value for each MCMC draw

if(currentRes$extra$priors$Rinit_prior[1] > 0 & currentRes$extra$priors$Rinit_prior[7] != 1) stop("Not starting from unfished equilibrium, so need to fix B0 values")

## AME changing RH's Year to currYearChar
currYearChar = rev(dimnames(currentMCMC$B)[[2]])[1]      
                # character current year (start for projections)
## AME changing RH's Year0 to currYear
currYear = as.numeric(currYearChar)         # numeric current year
startYearChar = dimnames(currentMCMC$B)[[2]][1]   # start year
startYear = as.numeric(startYearChar)

#Ypro  = dimnames(currentProj$B[[1]])[[2]]        # character available projection years
#Ypr0  = as.numeric(Ypro)                         # numeric available projection years

## To calculate trajectory for Bt/B0 MCMC's, do:
# BoverB0 = currentMCMC$B / B0.MCMC     # B/B0  each chain
# BoverB0med = apply(BoverB0, 2, median)         # median each year

B0.MCMC     = currentMCMC$B[,1,drop=FALSE]
Bcurr.MCMC  = currentMCMC$B[,currYearChar,drop=FALSE]
VB0.MCMC    = currentMCMC$VB[,grep(startYearChar,names(currentMCMC$VB)),drop=FALSE]
VBcurr.MCMC = currentMCMC$VB[,grep(currYearChar,names(currentMCMC$VB)),drop=FALSE]

# MSY procedure appears to only calculate one VB and U per MCMC sample
Bmsy.MCMC   = currentMSY$B
VBmsy.MCMC  = currentMSY$VB # only one VB is calculated in projections
msy.MCMC    = currentMSY$yield
umsy.MCMC   = currentMSY$u

## Gather MCMC values suggested by Trevor Davies (Dalhousie) for comparison
trevorMCMC = currentMCMC$P[,c("h","M_1","M_2")[is.element(c("h","M_1","M_2"),names(currentMCMC$P))],drop=FALSE]
trevorMCMC = data.frame(trevorMCMC, B0=B0.MCMC[,1], MSY=msy.MCMC, Bmsy=Bmsy.MCMC, umsy=umsy.MCMC, f=currentMCMC$L$f)

## To calculate the actual projected recruitments (from the eps)
currentProj$R = list()
NN = matrix(1:num.MCMC, nrow=1)      # to use to populate each data.frame
projYearsNames = names(currentProj$B[[1]])
projYearsNum   = length(projYearsNames)

## First calculate recruits for first projection year, which is based
##  on penultimate MCMC year's spawners (which is 2010, final year
##  of that is 2011, first proj year is 2011, and I checked that
##  values for last year of MCMC equal those for first yr of proj:
##  > range(currentMCMC$B[, 72] - currentProj$B$'250'[, 1]) 0 0.

## Do this here as does not depend on projections (and so is same for all catch strategies).
Bpen.MCMC = currentMCMC$B[, rev(names(currentMCMC$B))[2]]
     ## spawning biomass for penultimate year of MCMC

## Need a vector of h for projections, so if h not estimated
##  make hForProj just replicate the mpd value:

if (!is.element("h",use.Pnames))
  {hForProj = rep(currentRes$extra$parameters$h, num.MCMC) } else 
  { hForProj = currentMCMC$P$h }
  
RfirstProj = srFun(Bpen.MCMC, R0 = currentMCMC$P$R_0, h=hForProj, B0=B0.MCMC)

## Stochastic multiplier, will be same for all strategies as random
##  numbers currentProj$eps[[j]] are the same for each strategy j
stochMult = exp(currentProj$eps$'0' - sigmaR^2/2)

for(j in 1:length(currentProj$eps) )    # loop over policies
  {
  junk = apply(NN, 2, function(i, B, R0, h, B0) {
   srFun(as.numeric(B[i,]), h = h[i], R0=R0[i], B0=B0[1] ) },
   B = currentProj$B[[j]],
   R0 = currentMCMC$P$R_0, h = hForProj, B0=B0.MCMC[,1])  ## RH: I changed B0.MCMC to be a one-column matrix above to be comparable with VB0.MCMC
       ## Rowan's trick for using apply on each row.
  junk = t(junk)
  junk = as.data.frame(junk)
       ## This gives data frame,
       ##  rows are MCMC samples, columns are recruits for the
       ##  next year. Need to insert RfirstProj as first column,
       ##  and remove final column (which corresponds to recruits
       ##  for the year after final projection year).
  detR = cbind(RfirstProj, junk)
  detR = detR[, -dim(detR)[2] ]     # take off final column
  names(detR) = projYearsNames      # detR is deterministic values
  stochR = detR * stochMult
  currentProj$R[[j]] = stochR
  }
names(currentProj$R) = names(currentProj$eps)

@ %end <<MSY>> chunk

<<refpoints, results=hide, echo=FALSE>>=

#================================================================
# Bmsy Reference points (could move this to scape at some point):
# Need 10 year projections for 2012 POP 3CD 5DE assessment. Think
#  the calculations are done automatically (because we specified
#  10 years in the input .txt file), so maybe just have to play
#  with the output.

# Can probably remove these calculations, now that everything
#  seems to be done in Rowan's findTarget call below. Keeping
#  for now as these are what are used in Sweave for POP 3CD and 5DE.
#================================================================

refPointsList = refPoints(currentMCMC, currentProj, currentMSY, refLevels=c(0.4, 0.8, 1))  # default DFO settings (located in `PBSscape.r')
# See refPointsB0 for B0
refProbsList = calc.refProbs(currentProj$B, refPlist=refPointsList)  # default settings (located in `PBSscape.r')

# That's a list, each element is the full table for P > LRP, URP or Bmsy,
#  rows are const catch scenarios and columns are years.
# Full ymr calc is: 
# row.names(temp$LRP)
# [1] "0"    "250"  "500"  "750"  "1000" "1250" "1500" "1750" "2000" "2250"
# [11] "2500" "2750" "3000"
# row.names(t(temp$LRP))    # col.names didn't work?!
#  "2011" "2012" .... "2032"

# Adding in tenYear projections for POP 3CD and 5DE 2012.
# scenarioSubset = c("0", "500", "1000", "1500", "2000" "2250"....
fiveYears   = as.character(currYear+seq(0,5,1))
tenYears    = as.character(currYear+seq(0,10,1))
twentyYears = as.character(currYear+seq(0,20,5))
ninetyYears = as.character(currYear+seq(0,90,15))
pyYears     = as.character(currYear+seq(0,(projYearsNum-1),1))

refProbs5 = list()    # Probs for 5 years
refProbs10 = list()   # Probs for 10 years
refProbs20 = list()   # Probs for 20 years
refProbs90 = list()   # Probs for 90 years
refProbsPY = list()   # Probs for projYearsNum
for(i in 1:length(refProbsList))
	{
	refProbsPY[[i]] = refProbsList[[i]][,pyYears] # just in case the projections span some weird number of years
	names(refProbsPY)[i] = names(refProbsList)[i]
	if (projYearsNum>=5) {
		refProbs5[[i]] = refProbsList[[i]][,fiveYears]
		names(refProbs5)[i] = names(refProbsList)[i] }
	if (projYearsNum>=10) {
		refProbs10[[i]] = refProbsList[[i]][,tenYears]
		names(refProbs10)[i] = names(refProbsList)[i] }
	if (projYearsNum>=20) {
		refProbs20[[i]] = refProbsList[[i]][,twentyYears]
		names(refProbs20)[i] = names(refProbsList)[i] }
	if (projYearsNum>=90) {
		refProbs90[[i]] = refProbsList[[i]][,ninetyYears]
		colnames(refProbs90[[i]]) =  as.numeric(colnames(refProbs90[[i]])) - currYear
		names(refProbs90)[i] = names(refProbsList)[i] }
	}

# To check some random values:
# sum( currentProj$B[["1800"]][,"2019"] > 0.4 * Bmsy.MCMC)

# B0 Reference points, not doing moving window here yet 
#  (could move this to scape at some point):

# B0 reference points (NZ and US)
B0refLevels=c(0.2, 0.4, 0.5, 0.7)
B0refNames = paste("B0", B0refLevels, sep="")
refPointsB0List = refPointsB0(currentMCMC, currentProj, B0.MCMC, B0refLevels, B0refNames)  # Above two lines are defaults (function in `PBSscape.r')

refProbsB0List = calc.refProbs(currentProj$B, refPlist=refPointsB0List) # function in `PBSscape.r'
# That's a list, each element is the full table for P> each ref point,
#  rows are const catch scenarios and columns are years.
# Check, should get:
# row.names(temp$B00.2)
# [1] "0"    "250"  "500"....
# row.names(t(temp$B00.2))      colnames(...) works
#  "2011" "2012" .... "2101"

# scenarioSubset = c("0", "500", "1000", "1500", "2000" "2250"....

refProbsB05 = list()    # Probs for 5 years
refProbsB010 = list()   # Probs for 10 years
refProbsB020 = list()   # Probs for 20 years
refProbsB090 = list()   # Probs for 90 years
#refProbsB0PY = list()   # Probs for projYearsNum
for(i in 1:length(refProbsB0List))
	{
	if (projYearsNum>=5) {
		refProbsB05[[i]] = refProbsB0List[[i]][,fiveYears]
		names(refProbsB05)[i] = names(refProbsB0List)[i] }
	if (projYearsNum>=10) {
		refProbsB010[[i]] = refProbsB0List[[i]][,tenYears]
		names(refProbsB010)[i] = names(refProbsB0List)[i] }
	if (projYearsNum>=20) {
		refProbsB020[[i]] = refProbsB0List[[i]][,twentyYears]
		names(refProbsB020)[i] = names(refProbsB0List)[i] }
	if (projYearsNum>=90) {
		refProbsB090[[i]] = refProbsB0List[[i]][,ninetyYears]
		colnames(refProbsB090[[i]]) =  as.numeric(colnames(refProbsB090[[i]])) - currYear
		names(refProbsB090)[i] = names(refProbsB0List)[i] }
	}
# To give 0, 15 ... as colnames for decision tables
 

# Moving window reference points from Rowan's findTarget.r code (`PBSscape.r'),
#  which also calculates 0.4 Bmsy and others.

refProbs3GenList = list()        # Probabilities for decision tables
               #  Will include 0.4Bmsy etc. already calculated above
               #  e.g., refProbs3Gen5$'0.4Bmsy' - refProbs5$LRP  = 0
#list of targets:
Tlst = list(list(ratio=0.4,target=Bmsy.MCMC),
  list(ratio=0.8,target=Bmsy.MCMC),
  list(ratio=0.2,target=B0.MCMC[,1]),
  list(ratio=0.4,target=B0.MCMC[,1]),
  list(ratio=0.5,target=currentMCMC$B),
  list(ratio=0.7,target=currentMCMC$B),
  list(ratio=1.0,target=Bcurr.MCMC[,1]))
names(Tlst)=c("0.4Bmsy","0.8Bmsy","0.2B0","0.4B0","0.5Gen3","0.7Gen3", "Bcurr")


refProbs3GenList = sapply(Tlst,function(x){sapply(currentProj$B,
  findTarget,ratio=x$ratio,target=x$target,retVal="p.hi")}, simplify=FALSE)
refProbs3GenList = sapply(refProbs3GenList,t,simplify=FALSE) # transpose matrices

# And have to do separately for u_t > u_MSY:
Tlst.u = list(list(ratio=1,target=umsy.MCMC))
  # list(ratio=1,target=umsy.MCMC))
names(Tlst.u)=c("umsy") # , "umsyDummy")

# create table for u > umsy
#refProbs3GenList.u = list()  # RH: I keep forgetting that project U combines both commercial gears (I think)
#for (i in 1:Ngear) {
refProbs3GenList.u = sapply(Tlst.u,function(x){sapply(currentProj$U,
  findTarget,ratio=x$ratio,target=x$target,retVal="p.hi")}, simplify=FALSE)
refProbs3GenList.u = sapply(refProbs3GenList.u,t,simplify=FALSE) # transpose matrices

# If need 5/90 years then have to add in below:

# To just get probabilities for 5 or 90 years (if available)
refProbs3Gen5 = list()    # Probs for 5 years
refProbs3Gen90 = list()   # Probs for 90 years

for(i in 1:length(refProbs3GenList))
	{
	if (projYearsNum>=5) {
		refProbs3Gen5[[i]] = refProbs3GenList[[i]][,fiveYears]
		names(refProbs3Gen5)[i] = names(refProbs3GenList)[i] }
	if (projYearsNum>=90) {
		refProbs3Gen90[[i]] = refProbs3GenList[[i]][,ninetyYears]
		colnames(refProbs3Gen90[[i]]) =  as.numeric(colnames(refProbs3Gen90[[i]])) - currYear
		names(refProbs3Gen90)[i] = names(refProbs3GenList)[i] }
	}
# To give 0, 15 ... as colnames for decision tables

# Also calculate number of years to reach reference target points
#  with a specified confidence, 0.5, 0.8 and 0.95
Ttab0.5 = sapply(Tlst,function(x){sapply(currentProj$B,findTarget,ratio=x$ratio,target=x$target,conf=0.5,retVal="N")})
Ttab0.8 = sapply(Tlst,function(x){sapply(currentProj$B,findTarget,ratio=x$ratio,target=x$target,conf=0.8,retVal="N")})
Ttab0.95 = sapply(Tlst,function(x){sapply(currentProj$B,findTarget,ratio=x$ratio,target=x$target,conf=0.95,retVal="N")})

# Need to calculate exploitation rates over time for MCMC (MPD's are included in `currentRes', but nothing in `currentMCMC'.
# Going to add currentMCMC$U to currentMCMC. 
# After doing this realised it was sort of done in popScapeRuns2.r, but only internally for plotting figures.

catch = currentRes$B[,-1][,grep("Y",names(currentRes$B[,-1])),drop=FALSE]
if ( !all(is.na(catch[nrow(catch),])) ) stop("Check catch =   and  currentMCMC$U =     in run-masterMCMC.Snw") 
#if(!is.na( currentRes$B$Y[length(currentRes$B$Y)] )) stop("Check catch =   and  currentMCMC$U =     in run-masterMCMC.Snw") 
#catch = currentRes$B$Y[-length(currentRes$B$Y)]   # take off final NA
#names(catch) = years[-length(years)]
catch = catch[-nrow(catch),,drop=FALSE]
row.names(catch) = years[-length(years)]
CATCH = apply(catch,1,sum)

#currentMCMC$U = currentMCMC$VB[,-dim(currentMCMC$VB)[2]] # Don't want final, as no catch; already subset because VB was subset
currentMCMC$U = currentMCMC$VB[,grep(currYearChar,names(currentMCMC$VB),invert=TRUE)] # RH need to be tricky when Ngear>1
names.cmu = names(currentMCMC$U)

#VBcatch = rep(catch,Ngear); names(VBcatch)=names.cmu
VBcatch = unlist(catch); names(VBcatch)=names.cmu
currentMCMC$U = as.data.frame(t(apply(currentMCMC$U, 1, function(x,y){ y/x }, y=VBcatch)))    # Need transpose to get right way round again
# So currentMCMC$U is now exploitation rate for MCMC output.

#upenult.MCMC = currentMCMC$U[,as.character(currYear-1)]
upenult.MCMC = currentMCMC$U[,grep(as.character(currYear-1),names(currentMCMC$U)),drop=FALSE]
umax.MCMC = apply(currentMCMC$U, 1, max)

# From Rowan - quantiles for every year, then manually find the maximum median. 
# Not quite what I did above.
# Uquant = apply(currentMCMC$U,2,quantile,c(0.05,.5,0.95))
# Umean16 = apply(Uquant[,as.character(1997:2012)],1,mean)

# Catch for last num.recentCatchYears years of data:
num.recentCatchYears = 5

#if( diff(range(rev(catch)[1:2])) > 0.1 ) 
#   { stop("lastFiveCatch in run-masterMCMC.Snw assumes final year 
#       equals penultimate, but this isn't the case here so fix it") }

if( diff(range(rev(CATCH)[1:2])) < 0.7 )  # for 5DE the 2012
  {                                       #  was set to 2011 rounded 
    recentCatch = rev(rev(CATCH)[2:(2+num.recentCatchYears-1)])
              # The last num.recentCatchYears without the final year
              #  as have assumed that's not real data
  } else
  {  recentCatch = rev(rev(CATCH)[1:num.recentCatchYears])
  }

recentCatchMean = mean(recentCatch)
lab.recentCatchYears = paste(names(recentCatch)[c(1,num.recentCatchYears)],collapse="-")
refCatSentence = paste("For reference, the average ", catch.type, " catch over the last ", num.recentCatchYears, " years (", lab.recentCatchYears, ") is ", round(recentCatchMean, dig=0), "~t. ",sep="")

maxCatch = max(CATCH)
maxCatchYear = as.numeric(names(CATCH)[grep(maxCatch,CATCH)[1]])
if (any(spp.name=="ROL")){
	maxCatSentence = paste("The maximum historical female catch estimate in Area ", area.name, "  was ", round(maxCatch), "~t in ", maxCatchYear,". ",sep="")
} else { maxCatSentence = "" }

# u.MCMC.med = apply(currentMCMC$U, 2, median)  # median for each year
# For snail plots:
currentMCMC$UoverUmsy = as.data.frame(apply(currentMCMC$U, 2, function(x,y){ x/y },  y=umsy.MCMC))    # No transpose
UoverUmsy.med = apply(currentMCMC$UoverUmsy, 2, median)
#  qtab(currentMCMC$UoverUmsy[,"2010"], dig=3 )    agrees with values
#   below in the table

currentMCMC$BoverBmsy = as.data.frame(apply(currentMCMC$B, 2, function(x,y){ x/y },  y=Bmsy.MCMC))    # No transpose, also agrees with table below
BoverBmsy.med = apply(currentMCMC$BoverBmsy, 2, median)

save("currentMCMC",file="currentMCMC.rda")  ## useful to have when compiling the final results appendix

# Did this to check MPD's closely matched the medians, they more or less do:
# plot(apply(currentMCMC$U, 2, median))
# points(currentRes$B$U, col="red")

# For SARA need to calculate Z = M+F = M-log(1-u), so have to do for
#  females and males. Work it out for each MCMC draw, then get the 
#  quantiles from the resulting 1000 values. But if M fixed then
#  just have u to worry about.

# Estimate M:
# Z1 = currentMCMC$P[,"M_1"] - log(1 - upenult.MCMC)
# quantile(Z1, p=c(0.05, 0.50, 0.95))
# Z2 = currentMCMC$P[,"M_2"] - log(1 - upenult.MCMC)
# quantile(Z2, p=c(0.05, 0.50, 0.95))

# Fix M, for females (males the same if fixed values the same):
# Z1 = M1.prior[7] - log(1 - upenult.MCMC)
# quantile(Z1, p=c(0.05, 0.50, 0.95))

quantiles = c(0.05, 0.5, 0.95)      # for tables
# Next was for saving to an .RData file to load into 
#  ../../../POPdeterminR/POPdeterminR.r   to run deterministic model.
# First give variable names that match my write up, then save them 
#  all.
# First set are to be used as input, second set as confirmation.
# For YMR, for now commenting out ones from MCMC.

A = max(currentRes$Sel[,"Age"])
#T = diff(range(currentRes$B[,"Year"]))+1       # =72
Ct = currentRes$B$Y[-length(currentRes$B$Y)]    # Takes off 2011 value
# years = currentRes$B[,"Year"]    # moving earlier
ages = sort(unique(currentRes$CAc$Age))

selgeqComm = currentRes$Sel[currentRes$Sel$"Series" == "Gear 1",] 
    # comm sel, selgeq4 for POP, presumably woudl be 6 for YMR as
    #  5 surveyrs, so just write Comm
#mat = currentRes$Sel[currentRes$Sel$"Series" == "Maturity" & currentRes$Sel$"Sex" == "Female",]      # Female maturity
mat = currentRes$Sel[is.element(currentRes$Sel$"Series","Maturity") & is.element(currentRes$Sel$"Sex",c("Female","Unisex")),]  # Female maturity
# M1 = currentMCMC$P[1,"M_1"]                 # MPD is first line of MCMC
# M2 = currentMCMC$P[1,"M_2"]                 # MPD is first line of MCMC
Rt = currentRes$B$R[-length(currentRes$B$R)]  # Remove final NA for the last year,
Rt.mpd = Rt       # don't think Rt gets used elsewhere, but leave it valid just in case.
# For confirmation:
# R0.mpd = currentMCMC$P[1,"R_0"] #Matches numbers from Ro_So_VB.pst,
                                  # but wasn't going to use that 
                                  #  before?
# h.mpd = currentMCMC$P[1,"h"]
Nats.mpd = currentRes$N
#ut.mpd = currentRes$B$U[-length(currentRes$B$U)]  # remove final NA for the last year
ut.mpd = currentRes$B[1:(nrow(currentRes$B)-1),grep("U",names(currentRes$B)),drop=FALSE]  # RH: need in case Ngear > 1
Bt.mpd = currentRes$B[,"SB",drop=FALSE]
B0.mpd = Bt.mpd[1,1]       #****CHANGE*** if change init cdts.
Vt.mpd = currentRes$B[,grep("V",names(currentRes$B)),drop=FALSE]  # RH: need in case Ngear > 1
logRecDev.mpd = currentRes$Dev$Annual
# Also equals currentRes$extra$parameters$log_RecDev from Rowan's 'extra' sublist  in currentRes.

# AME deleted lots of commented out code. 20th August 2012.

#-----------------------------------------------------
# RH adding historical refrerence points for Rock Sole
#-----------------------------------------------------
if (is.element(spp.name,c("ROL","rol","621"))) {
	if (area.name=="5CD") HRP.YRS = list(blimYrs=1966:2005, btarYrs=1971:1980, ulimYrs=NULL, utarYrs=1966:2005)
	else                  HRP.YRS = list(blimYrs=1966:2005, btarYrs=1977:1985, ulimYrs=NULL, utarYrs=1966:2005)
} else {
	HRP.YRS = list(blimYrs=1966:2005, btarYrs=1977:1985, ulimYrs=NULL, utarYrs=1966:2005)
}
refPointsHistList = refPointsHist(HRP.YRS=HRP.YRS)  # pass in list of obscure years for calculating Rock Sole historical ref points (B & u MCMCs)

if (is.element(spp.name,c("ROL","rol","621"))) {
	trevorMCMC = data.frame(trevorMCMC, 
		Blim = refPointsHistList$blimHRP,
		Btar = refPointsHistList$btarHRP,
		utar = refPointsHistList$utarHRP ) }

hrp.B = calc.refProbsHist(currentProj$B,refPointsHistList[c("blimHRP","btarHRP")]) # default values (function in `PBSscape.r')
hrp.U = calc.refProbsHist(currentProj$U,refPointsHistList[c("ulimHRP","utarHRP")]) # function in `PBSscape.r'
refProbsHistList = c(hrp.B,hrp.U)

# That's a list, each element is the full table for P> LRP, URP or Bmsy, rows are const catch scenarios and columns are years.

# Adding in tenYear projections for POP 3CD and 5DE 2012.
# scenarioSubset = c("0", "500", "1000", "1500", "2000" "2250"....
fiveYears   = as.character(currYear+seq(0,5,1))
tenYears    = as.character(currYear+seq(0,10,1))
twentyYears = as.character(currYear+seq(0,20,5))
ninetyYears = as.character(currYear+seq(0,90,15))

refProbsHist5 = list()    # Probs for 5 years
refProbsHist10 = list()   # Probs for 10 years
refProbsHist20 = list()   # Probs for 20 years
refProbsHist90 = list()   # Probs for 90 years
for(i in 1:length(refProbsHistList))
	{
	if (is.null(refProbsHistList[[i]])) next
	if (projYearsNum>=5) {
		refProbsHist5[[i]] = refProbsHistList[[i]][,fiveYears]
		names(refProbsHist5)[i] = names(refProbsHistList)[i] }
	if (projYearsNum>=10) {
		refProbsHist10[[i]] = refProbsHistList[[i]][,tenYears]
		names(refProbsHist10)[i] = names(refProbsHistList)[i] }
        if (projYearsNum>=20) {
		refProbsHist20[[i]] = refProbsHistList[[i]][,twentyYears]
		names(refProbsHist20)[i] = names(refProbsHistList)[i] }
	if (projYearsNum>=90) {
		refProbsHist90[[i]] = refProbsHistList[[i]][,ninetyYears]
		colnames(refProbsHist90[[i]]) =  as.numeric(colnames(refProbsHist90[[i]])) - currYear
		names(refProbsHist90)[i] = names(refProbsHistList)[i] }
	}
@  % end of <<refpoints>> chunk


\newcommand{\currYear}{\Sexpr{currYear}} % so can include in captions. 

<<plottingFigs, results=hide, echo=FALSE>>=
# Moved from above, as now have currentMCMC$U calcs
# plt.idx( currentRes$Survey,main="Survey Indices") # wasn't called 
#  in plt.mpdGraphs. Doing it here spits out SD of standardised 
#  residuals also. May be useful for iterative reweighting?

#meanPolicy = round(mean(recentCatch),-floor(log10(mean(recentCatch))))
#meanCatch  = mean(recentCatch) # already calculated as `recentCatchMean` on line 823
projPolicy = as.numeric(names(currentProj$Y))
nPolicy    = length(projPolicy)
onePos     = round(approx(projPolicy,y=1:nPolicy,xout=recentCatchMean)$y)
if (is.na(onePos)) stop("projPolicy range does not cover recent mean catch")
nPanel     = 6    # assume 6 panels in plot
incPos     = floor(nPolicy/nPanel)
prjPos = onePos #starting point
while(length(prjPos)!=(nPanel)) {
	if (min(prjPos)-incPos > 0) prjPos = c(min(prjPos)-incPos,prjPos)
	if (max(prjPos)+incPos <= nPolicy) prjPos = c(prjPos,max(prjPos)+incPos)
	if (length(prjPos)>(nPanel)) prjPos=prjPos[1:(nPanel)]
print(prjPos)
}
prjPos[1] = 1 # always have 0-catch policy
onePolicy  = projPolicy[onePos]
plotPolicy = projPolicy[prjPos]

if(redo.Graphs)
	plt.mcmcGraphs( mcmcObj=currentMCMC, projObj=currentProj, mpdObj=currentRes, save=TRUE, 
		ptypes=tcall(PBSawatea)$ptype, pngres=400, ngear=Ngear,
		plotPolicies = as.character(plotPolicy), #plotPolicies = names(currentProj$Y[1:6]),
		onePolicy    = as.character(onePolicy),  #onePolicy = names(currentProj$Y[2]), 
		mpd=list(mpd.P=mpd.P, mpd.B=mpd.B, mpd.R=mpd.R),
		trevObj = trevorMCMC
	)
# plt.mcmcGraphs( mcmcObj=currentMCMC, projObj=currentProj, save=TRUE, ptypes=tcall(PBSawatea)$ptype, pngres=400, ngear=Ngear, plotPolicies = as.character(plotPolicy), onePolicy = as.character(onePolicy), mpd=list(mpd.P=mpd.P, mpd.B=mpd.B, mpd.R=mpd.R), trevObj = trevorMCMC) # for debugging only
# Change policy options if want other catch policies shown.
# Set up for length(plotPolicies)=6
# See help for other options.
# close.allWin()
# }

# function to use for priors in MPD table. Must read in a vector of 
#  length, and outputs it in the format for the table.
ptab = function(xx) 
  { print(paste(c(xx[1], " & [", xx[2], ",", xx[3], "] & ", 
          xx[4], " & [", xx[5], ",", xx[6], "] & ", xx[7]),
          sep="", collapse="")) 
  }
qtab = function(xx.MCMC, dig=0)     # dig is number of dec places
  { print(paste( c( prettyNum(round(quantile(xx.MCMC, 0.05), 
                                  digits=dig), big.mark=","), 
         " & ", prettyNum(round(quantile(xx.MCMC, 0.50), digits=dig),
                                  big.mark=","),
         " & ", prettyNum(round(quantile(xx.MCMC, 0.95), digits=dig),
                                  big.mark=",")), 
         sep="", collapse=""))
  }  

# to give median (5%-95%) to put in text.
med5.95 = function(xx.MCMC, dig=0)     # dig is number of dec places
  { print(paste( c( prettyNum(round(quantile(xx.MCMC, 0.50), digits=dig),
                                  big.mark=","), 
         "~(",  
                    prettyNum(round(quantile(xx.MCMC, 0.05), 
                                  digits=dig), big.mark=","), 
         "-", prettyNum(round(quantile(xx.MCMC, 0.95), digits=dig),
                                  big.mark=","), ")"),
         sep="", collapse=""))
  }  


# For q_i in table, values can vary between runs, so set to number
#  of significant digits. NOT USED, just doing 4 decimal places
#  for all. 
# sapply(signif(x,3), sprintf, fmt="%#.3g")   # try that for 
#  1.3001  to be 1.300.   Haven't played with yet.
qqtab = function(xx.MCMC, dig=3)     # dig is number sig digits
  { print(paste( c( prettyNum(signif(quantile(xx.MCMC, 0.05), 
                                  digits=dig), big.mark=","), 
        " & ", prettyNum(signif(quantile(xx.MCMC, 0.50), digits=dig),
                                  big.mark=","),
        " & ", prettyNum(signif(quantile(xx.MCMC, 0.95), digits=dig),
                                  big.mark=",")), 
         sep="", collapse=""))
  }  
# not saving for YMR for now (don't have all these variables, though
# just MPDs so don't need MCMC output).  [These were from MCMC's]
# save(A, T, Ct, selgeqComm, mat, M1, M2, Rt, R0.mpd, h.mpd, Nats.mpd, ut.mpd,  Bt.mpd, B0.mpd, Vt.mpd, logRecDev.mpd, file="run23values.RData")
# save.image(file="run23all.RData")

# See popScape2.r for pairs plots, from:
# Copy and run this for pairs plots        to
# text(currentRes$B$SB, currentRes$B$U, 1:72)

# Want to report the mean of the median recruitments for past and projections.
recMed = apply(currentMCMC$R, 2, median)
meanRecMed = mean(recMed)

muMed = apply(currentMCMC$P[grep("mu_",names(currentMCMC$P))],2,median)

# Do for one policy
# recProjMed1500 = apply(currentProj$R$'1500', 2, median)
# meanRecProjMed1500 = mean(recProjMed1500)

# Want to report the year of first age data:
CAfirstYear = min(min(currentRes$CAc$Year), min(currentRes$CAs$Year))
@ 

<<getMPDfigs, results=hide, echo=FALSE>>=
if (resdoc) {
	if (is.element(spp.name,c("SGR","POP","YMR"))) {
		mpdfigs = c("survIndSer2","meanage","commAgeResids","stockRecruit","recruits","selectivity","exploit")
		mpdfigs = paste(mpdfigs,".eps",sep="")
		mpdfigs = c(mpdfigs,list.files(mpd.dir,pattern=c("ageComm")))
		mpdfigs = c(mpdfigs,list.files(mpd.dir,pattern=c("ageSurv")))
		mpdfigs = c(mpdfigs,list.files(mpd.dir,pattern=c("survRes")))
		mpdfigs = c(mpdfigs,list.files(mpd.dir,pattern=c("survAgeResSer")))
		mpdfigs = c(mpdfigs,list.files(mpd.dir,pattern=c("recDev")))
	}
	if (is.element(spp.name,c("ROL"))) {
		mpdfigs = c("survIndSer2","CPUEser","commAgeResids","stockRecruit")
		mpdfigs = paste(mpdfigs,".eps",sep="")
		mpdfigs = c(mpdfigs,list.files(mpd.dir,pattern=c("ageComm")))
		mpdfigs = c(mpdfigs,list.files(mpd.dir,pattern=c("ageSurv")))
		mpdfigs = c(mpdfigs,list.files(mpd.dir,pattern=c("survRes")))
		mpdfigs = c(mpdfigs,list.files(mpd.dir,pattern=c("survAgeResSer")))
		mpdfigs = c(mpdfigs,list.files(mpd.dir,pattern=c("recDev")))
	}
	## There's no longer a need to copy these figures as the Model Results Appendix
	##   can navigate to various directories using \graphicspath. For example:
	## \graphicspath{{C:/Users/haighr/Files/GFish/PSARC17/POP/Data/Awatea/5ABC/POPrun08/MPD.08.03/}}
	## \input{"POPrun08-3"}
	## file.copy(from=paste(mpd.dir,mpdfigs,sep="/"),to=fig.dir,overwrite=TRUE)
}
@
@resultsMPD
@resultsMPDfigs % RH: MPD figures will be inserted here from the working directory (e.g., from `resultsMPDfigs-run16.tex`)

%======================START FIGURES=======================
\onefig{traceParams}{MCMC traces for the estimated parameters\Sexpr{print(in.area)}. Grey lines show the \numMCMC~samples for each parameter, solid lines show the cumulative median (up to that sample), and dashed lines show the cumulative 2.5 and 97.5 quantiles.  Red circles are the MPD estimates. For parameters other than $M$ (if estimated), subscripts $\leq \Sexpr{Nsurv}$ correspond to fishery-independent surveys, and subscripts $\geq \Sexpr{Nsurv+1}$ denote the commercial fishery. Parameter notation is described in Appendix~\eqnchapter.}

\onefig{splitChain}{Diagnostic plot\Sexpr{from.area} obtained by dividing the MCMC chain of \numMCMC~MCMC samples into three segments, and overplotting the cumulative distributions of the first segment (green), second segment (red) and final segment (blue).}
% overplotting the cumulative distributions, removing the first 100, then plotting the cumulative distributions for samples 101-400 (green), 301-700 (red) and 701-1000 (blue). }

\onefig{paramACFs}{Autocorrelation plots for the estimated parameters from the MCMC output. Horizontal dashed blue lines delimit the 95\% confidence interval for each parameter's set of lagged correlations.}

\clearpage

%=======This line will be expanded to accomodate multiple pairs plots=======
@rmresdoc \onefig{pairs1}{Pairs plot\Sexpr{from.area} of \numMCMC~MCMC samples for 1$^\text{st}$ six parameters. Numbers in the lower panels are the absolute values of the correlation coefficients.}

\onefig{pairsPars}{Pairs plot\Sexpr{from.area} of \numMCMC~MCMC samples for \Sexpr{length(use.Pnames)} parameters. Numbers in the lower panels are the absolute values of the correlation coefficients.}

\onefig{pairsMSY}{Pairs plot\Sexpr{from.area} of \numMCMC~MCMC samples comparing some parameters, key derived quantities, and function value (f). Numbers in the lower panels are the absolute values of the correlation coefficients.}

\clearpage

@rmROL \onefig{traceBiomass}{MCMC traces\Sexpr{from.area} for female spawning biomass estimates at five-year intervals.  Note that vertical scales are different for each plot (to show convergence of the MCMC chain, rather than absolute differences in annual values). Grey lines show the \numMCMC~samples for each parameter, solid lines show the cumulative  median (up to that sample), and dashed lines show the cumulative  2.5 and 97.5 quantiles.  Red circles are the MPD estimates.}

@rmROL \onefig{traceRecruits}{MCMC traces\Sexpr{from.area} for recruitment estimates at five-year intervals. Note that vertical scales are different for each plot (to show convergence of the MCMC chain, rather than absolute differences in annual recruitment). Grey lines show the \numMCMC~samples for each parameter, solid lines show the cumulative  median (up to that sample), and dashed lines show the cumulative  2.5 and 97.5 quantiles.  Red circles are the MPD estimates.}

\onefig{pdfParameters}{Marginal posterior densities (thick black curves) and prior density functions (thin blue curves) for the estimated parameters\Sexpr{from.area}. Vertical lines represent the 2.5, 50 and 97.5 percentiles, and red filled circles are the MPD estimates. For $R_0$ the prior is a uniform distribution on the range [\Sexpr{priorInput["R_0",2]}, \Sexpr{priorInput["R_0",3]}]. The priors for $q_g$ are uniform on a log-scale, and so the probability density function is $1/(x(b-a))$ on a linear scale (where $a$ and $b$ are the bounds on the log scale).}
% such that half of the weight of the prior distribution lies $>0.03$ [**for the parameters used in YMR], which is not obvious from the graphs. 

\clearpage
% \onefig{selectivityMCMC}{**** Rowan's favourite figure.*** MCMC selectivity figure will go here, haven't calculated yet (started in {\tt plotSelMCMC.r}---- couldn't find that anywhere, so just see prior calculation folder rprogs/POP12/Mprior).}

@rmresdoc \onefig{pdfBiomass}{Marginal posterior densities for beginning year female spawning biomass (1,000 tonnes) every 5 years starting in \Sexpr{startYear} for run \Sexpr{model.name}. Horizontal axes are all to same scale. Note that vertical axes are not to the same scale, but each is scaled to the peak of the density; with the area under each curve integrating to 1.0. Vertical lines are 2.5, 50 and 97.5 percentiles, and filled red circle indicates MPD value.}

@rmresdoc \onefig{pdfRecruitment}{Marginal posterior densities for recruitment every 5 years starting in \Sexpr{startYear} for run \Sexpr{model.name}. Horizontal axes are all to same scale, such that large recruitments in certain large years can be seen. Note that vertical axes are not to the same scale, but each is scaled to the peak of the density; areas under each curve will integrate to 1.0. Vertical lines are 2.5, 50 and 97.5 percentiles, and filled red circle indicates MPD value. }

\clearpage

% To go into main docco (except summary table to stay in App G).

\onefig{VBcatch}{Estimated vulnerable biomass (boxplots) and commercial catch (vertical bars), in tonnes, over time\Sexpr{for.area}. Boxplots show the 2.5, 25, 50, 75 and 97.5 percentiles from the MCMC results. Catch is shown to compare its magnitude to the estimated vulnerable biomass.}

\onefig{BVBnorm}{Changes in $B_t / B_0$ and $V_t / V_0$ (spawning and vulnerable biomass relative to unfished equilibrium levels) over time\Sexpr{for.area}, shown as the medians of the MCMC posteriors.}

<<muIndex, results=hide, echo=FALSE>>=
if (length(muMed)>0) {
	muCI = findPat((Nsurv+1):(Nsurv+Ncomm),names(muMed))
	names(muCI) = sapply(strsplit(muCI,"_"),function(x){x[2]})
	muSI=findPat(1:Nsurv,names(muMed))
	names(muSI) = sapply(strsplit(muSI,"_"),function(x){x[2]})
} else {
	muCI = currentRes$extra$priors$p_Sfullest[,7]
	muSI = currentRes$extra$priors$surveySfull_prior[,7]
}
@

\onefig{recruitsMCMC}{Marginal posterior distribution of recruitment in 1,000s of age-1 fish plotted over time\Sexpr{for.area}. Boxplots show the 2.5, 25, 50, 75 and 97.5 percentiles from the MCMC results. Note that the first year for which there are age data is \Sexpr{CAfirstYear}, and the plus-age class is \Sexpr{A}, such that there are no direct data concerning age-1 fish before \Sexpr{CAfirstYear-A+1}. Also, the final few years have no direct age-data from which to estimate recruitment, because fish are not fully selected until age \Sexpr{round(mean(muMed[muCI]),1)} by the commercial vessels or age \Sexpr{round(mean(muMed[muSI]),1)} by surveys (mean of the MCMC median ages at full selectivity for commercial catch, $\mu_{\Sexpr{paste(names(muCI),collapse=",")}}$, and survey $\mu_{\Sexpr{paste(names(muSI),collapse=",")}}$, respectively).}

\onefig{exploitMCMC}{Marginal posterior distribution of exploitation rate\Sexpr{in.area} plotted over time. Boxplots show the 2.5, 25, 50, 75 and 97.5 percentiles from the MCMC results.}

% **** ADD in in latex  ****
%\begin{figure}[htp]
%\begin{center}
%\epsfxsize=6in
%\epsfbox{selectivityMCMC}
% \epsfbox{"C:/Documents and Settings/edwardsand/My Documents/latex/POP12/POP3CDworkPaper/mainDoc/CompBmsy-POP-(5DE 5ABC 3CD).eps"}
%\end{center}
%\caption{**Replace figure with Rowan's for write-up; already put into main.tex**. Current status of the three Canadian POP stocks relative to the DFO Precautionary Approach provisional reference points of $0.4 \Bmsy$ and $0.8 \Bmsy$. The stocks are shown from north to south, and $B_t / \Bmsy$ is for $t=\Sexpr{currYear}$ for 5DE \citep{\otherCite} and 3CD (this assessment), and for $t=2011$ for area 5ABC (run `Estimate $M \& h$' from \citealt{\popQCS}). Boxplots show the 5, 25, 50, 75 and 95 percentiles from the MCMC results.}
%\label{fig:compBmsy} 
%\end{figure}

\onefig{snail}{Phase plot through time of the medians of the ratios $B_t/B_\mathrm{MSY}$ (the spawning biomass in year $t$ relative to $B_\mathrm{MSY}$) and $u_{t-1} / u_\mathrm{MSY}$ (the exploitation rate in year $t-1$ relative to $u_\mathrm{MSY}$)\Sexpr{for.area}. The filled cyan circle is the starting year (\Sexpr{startYear+1}). Years then proceed from light grey through to dark grey with the final year (\Sexpr{currYear}) as a filled blue circle, and the blue lines represent the 10\% and 90\% percentiles of the posterior distributions for the final year. The filled gold circle indicates the status in 2011 ($B_{2011}/B_\mathrm{MSY}$, $u_{2010}/u_\mathrm{MSY}$), which coincides with the previous assessment in 2010. Red and green vertical dashed lines indicate the Precautionary Approach provisional limit and upper stock reference points (0.4, 0.8 $\Bmsy$), and the horizontal grey dotted line indicates $u$ at MSY.} %% Cannot have braces {} within an \Sexpr{} (stupid)

\onefig{Bproj}{Projected biomass (t) under different constant catch strategies (t)\Sexpr{for.area}; boxplots show the 2.5, 25, 50, 75 and 97.5 percentiles from the MCMC results. For each of the \numMCMC~samples from the MCMC posterior, the model was run forward in time (red, with medians in black) with a constant catch, and recruitment was simulated from the stock-recruitment function with lognormal error (see Appendix~\eqnchapter). \Sexpr{refCatSentence}}

\clearpage 

% Commenting out for WG meeting, plus not so useful for short 
%  projections. Though now doing 10 years, and I think's useful to 
%  raise caution about how the projections are done. 

@rmresdoc \onefig{Rproj}{Projected recruitments (red) under different constant catch strategies (boxplots show the 2.5, 25, 50, 75 and 97.5 percentiles from the MCMC results; historical recruitments in black).}

% xx = apply(currentProj$R$'0', 2, max)
% summary(xx)
  
% Commenting out for WG meeting, as above.
% \onefig{RprojOnePolicy}{Projected recruitments for just ** constant catch strategy (to go into SAR) for run \Sexpr{model.name}~(boxplots show the 2.5, 25, 50, 75 and 97.5 percentiles from the MCMC results). This shows that the random projected recruitments are fairly similar from year-to-year, without the large recruitment events that are seen in the past. While individual MCMC simulations may have occasional large recruitments, this will not happen for a particular year for all MCMC simulations concurrently, which did happen in the past (so, in particular, the lowest estimates of recruitment were still high). The mean of the median historical recruitments is \Sexpr{round(meanRecMed, digits=0)}.}  
%, whereas the mean of the median projected recruitments is *** } 
% xx = apply(currentProj$R$'1500', 2, median)
% mean(xx)   
% yy = apply(currentMCMC$R, 2, median)
% mean(yy)

%======================START TABLES=======================
\clearpage     % to get tables at end
@resultsMPDtabs % RH: MPD tables will be inserted here from the working directory (e.g., from `resultsMPDtabs-run16.tex`)

<<tabmcmc, results=tex, echo=FALSE>>=
	tabdigits = 3      # number of decimal places to give
	tabmcmc  = t(sapply(currentMCMC$P,quantile,c(0.05,0.50,0.95)))
	if (exists("formatCatch")) { tabmcmc = formatCatch(tabmcmc,N=4) } else { tabmcmc["R_0",] = round(tabmcmc["R_0",]) }
	names.mcmc = rownames(tabmcmc)
	fixsub = grep("_",names.mcmc)
	names.mcmc[fixsub] = paste0(sub("_","_{",names.mcmc[fixsub]),"}")
	names.mcmc = gsub("mu","\\\\mu",names.mcmc)
	names.mcmc = gsub("Delta","\\\\Delta",names.mcmc)
	names.mcmc = sub("log","\\\\mathrm{log}",names.mcmc)
	#names.mcmc = gsub("log","\\\\mathrm{log}",gsub("v_","v_{",gsub("L","L}",names.mcmc)))
	rownames(tabmcmc) =  paste(rep("$",nrow(tabmcmc)),names.mcmc,rep("$",nrow(tabmcmc)),sep="")
	xtabmcmc = xtable(tabmcmc, align="crrr",
		label   = "tab:MCMCpar", digits = if (exists("formatCatch")) NULL else tabdigits,
		caption = paste("The 5\\super{th}, 50\\super{th}, and 95\\super{th} percentiles for model parameters derived via MCMC estimation (defined in Appendix~\\eqnchapter)",for.area,".",sep="") )
		#caption = "Summary statistics of MCMC results for estimated parameters (defined in Appendix~\eqnchapter)." )
	print(xtabmcmc, caption.placement="top",
		sanitize.rownames.function=function(x){x},
		add.to.row =list(pos = list(-1), command = c("\\\\[-1.0ex]"))
	)
@

% Want to automate this, best to do by changing the qtab function
%  to print out the whole row (including $q_4$ etc.), and do it
%  only for ones in use.Pnames. Will just then loop around that
%  for length(use.Pnames). For now it gives NA's for ones not
%  being estimated, so putting up to g=4 because that's what
%  we have for POP 3CD (so just simplify when writing up 3CD and 5DE).

\clearpage

%=====TABLE: MCMC QUANTILES=====
\begin{table}[tp]
\centering
\caption{\label{tab:MCMCderived} The 5$^\mathrm{th}$, 50$^\mathrm{th}$ and 95$^\mathrm{th}$ percentiles of MCMC-derived quantities from the \numMCMC~samples of the MCMC posterior\Sexpr{from.area}. Definitions are:
 $B_0$ -- unfished equilibrium spawning biomass (mature females), 
 $V_0$ -- unfished equilibrium vulnerable biomass (males and females), 
 $B_{\Sexpr{currYear}}$ -- spawning biomass at the start of $\Sexpr{currYear}$, 
 $V_{\Sexpr{currYear}}$ -- vulnerable biomass in the middle of \Sexpr{currYear}, 
 $u_{\Sexpr{currYear-@one}}$ -- exploitation rate (ratio of total catch to vulnerable biomass) in the middle of \Sexpr{currYear-@one}, 
 $u_\mathrm{max}$ -- maximum exploitation rate (calculated for each sample as the maximum exploitation rate from \Sexpr{substring(names(currentMCMC$U[1,])[1],1,4)}-\Sexpr{substring(rev(names(currentMCMC$U[1,]))[1],1,4)}), 
 $\Bmsy$ -- equilibrium spawning biomass at MSY (maximum sustainable yield), 
 $u_\mathrm{MSY}$ -- equilibrium exploitation rate at MSY, 
 $V_\mathrm{MSY}$ -- equilibrium vulnerable biomass at MSY. 
@rmhrp The values $B_\mathrm{Lim}$ and $B_\mathrm{Tar}$ denote historical limit and target reference points min($B_{\Sexpr{paste(range(HRP.YRS$blimYrs),collapse="-")}}$) and mean($B_{\Sexpr{paste(range(HRP.YRS$btarYrs),collapse="-")}}$), respectively. The historical target exploitation rate is expressed as the mean($u_{\Sexpr{paste(range(HRP.YRS$utarYrs),collapse="-")}}$).
All biomass values (and MSY) are in tonnes. \Sexpr{refCatSentence} }
\begin{tabular}{lrrr} 
\\[-1.0ex]\hline
Value & \multicolumn{3}{c}{Percentile}\\
\cline{2-4}
 & 5\% & 50\% & 95\% \\
\hline 
% & & & \\ %CSAS in Ottawa wants blank rows removed (AME 170427)
& \multicolumn{3}{c}{From model output}\\
$B_0$                  & \Sexpr{qtab(B0.MCMC[,1])} \\
%=======Next line will be expanded to accomodate multiple gears=======
$V_{0,g=\Sexpr{GI[1]}}$                  & \Sexpr{qtab(VB0.MCMC[,1])} \\
$B_{\Sexpr{currYear}}$             & \Sexpr{qtab(Bcurr.MCMC[,1])} \\
%=======Next line will be expanded to accomodate multiple gears=======
$V_{\Sexpr{currYear},g=\Sexpr{GI[1]}}$             & \Sexpr{qtab(VBcurr.MCMC[,1])} \\

$B_{\Sexpr{currYear}} / B_0$       & \Sexpr{qtab(Bcurr.MCMC[,1] / B0.MCMC[,1], dig=3)} \\
%=======Next line will be expanded to accomodate multiple gears=======
$V_{\Sexpr{currYear},g=\Sexpr{GI[1]}} / V_{0,g=\Sexpr{GI[1]}}$     & \Sexpr{qtab(VBcurr.MCMC[,1]/VB0.MCMC[,1], dig=3)} \\

%=======Next line will be expanded to accomodate multiple gears=======
$u_{\Sexpr{currYear-@one},g=\Sexpr{GI[1]}}$             & \Sexpr{qtab(upenult.MCMC[,1],dig=3)} \\
$u_\mathrm{max}$       & \Sexpr{qtab(umax.MCMC, dig=3)} \\
\hline
% & & & \\ %CSAS in Ottawa wants blank rows removed (AME 170427)
& \multicolumn{3}{c}{MSY-based quantities}\\
$\mathrm{MSY}$                    & \Sexpr{qtab(msy.MCMC)} \\
$B_\mathrm{MSY}$       &  \Sexpr{qtab(Bmsy.MCMC)} \\
$0.4 B_\mathrm{MSY}$   &  \Sexpr{qtab(0.4*Bmsy.MCMC)} \\
$0.8 B_\mathrm{MSY}$   &  \Sexpr{qtab(0.8*Bmsy.MCMC)} \\
$B_{\Sexpr{currYear}} / B_\mathrm{MSY}$ & \Sexpr{qtab(Bcurr.MCMC[,1] / Bmsy.MCMC, dig=3)} \\
$B_\mathrm{MSY} / B_0$ &  \Sexpr{qtab(Bmsy.MCMC / B0.MCMC[,1], dig=3)} \\
%
$V_\mathrm{MSY}$       & \Sexpr{qtab(VBmsy.MCMC)} \\
%=======Next line will be expanded to accomodate multiple gears=======
$V_\mathrm{MSY} / V_{0,g=\Sexpr{GI[1]}}$ & \Sexpr{qtab(VBmsy.MCMC/VB0.MCMC[,1], dig=3)} \\
%
$u_\mathrm{MSY}$       & \Sexpr{qtab(umsy.MCMC, dig=3)} \\
%=======Next line will be expanded to accomodate multiple gears=======
$u_{\Sexpr{currYear-@one},g=\Sexpr{GI[1]}} / u_\mathrm{MSY}$ & \Sexpr{qtab(upenult.MCMC[,1]/umsy.MCMC, dig=3)} \\
\hline
@rmhrp  & & & \\
@rmhrp & \multicolumn{3}{c}{History-based quantities}\\
@rmhrp $B_\mathrm{Lim}$  & \Sexpr{qtab(refPointsHistList$blimHRP)} \\
@rmhrp $B_\mathrm{Tar}$  & \Sexpr{qtab(refPointsHistList$btarHRP)} \\
@rmhrp $B_{\Sexpr{currYear}} / B_\mathrm{Lim}$  & \Sexpr{qtab(Bcurr.MCMC[,1]/refPointsHistList$blimHRP, dig=3)} \\
@rmhrp $B_{\Sexpr{currYear}} / B_\mathrm{Tar}$  & \Sexpr{qtab(Bcurr.MCMC[,1]/refPointsHistList$btarHRP, dig=3)} \\
@rmhrp $u_\mathrm{Tar}$       & \Sexpr{qtab(refPointsHistList$utarHRP, dig=3)} \\  % note to future: should this have Ngear dimensions?
@rmhrp %=======Next line will be expanded to accomodate multiple gears=======
@rmhrp $u_{\Sexpr{currYear-@one}} / u_\mathrm{Tar}$ & \Sexpr{qtab(upenult.MCMC[,1]/refPointsHistList$utarHRP, dig=3)} \\
@rmhrp \hline
\end{tabular}
\end{table}

\clearpage

% For Decision table write up **** add something like this to the header:
% \multicolumn{7}{l}{P$(B_t > 0.4 \Bmsy)$} \\
%  \hline
%Annual catch & \multicolumn{6}{c}{Projection year} \\
%\cline{2-7}
%strategy & 2011 & 2012 & 2013 & 2014 & 2015 & 2016 \\

<<tables, results=tex, echo=FALSE>>=
tabdigits = ifelse(resdoc,2,3)    ## number of decimal places to give (AME likes 2)

#=====TABLE: DEFAULT DFO MSY REFERENCE POINTS=====
if (exists("refProbs10") || exists("refProbs5")) {
	if (projYearsNum >= 10) {
			refProbs = refProbs10
	} else {
		refProbs = refProbs5
	}
	# it didn't like \Sexpr in caption="" - need eval(paste
	xtabLRP = xtable(refProbs$LRP, label="tab:LRP", digits=tabdigits,
		caption=eval(paste("Decision table",for.area," concerning the limit reference point $0.4 \\Bmsy$ for 1-",projYearsNum-1," year projections for a range of constant catch strategies (in tonnes). Values are P$(B_t > 0.4 \\Bmsy)$, i.e.~the probability of the spawning biomass (mature females) at the start of year $t$ being greater than the limit reference point. The probabilities are the proportion (to two decimal places) of the ", num.MCMC, " MCMC samples for which $B_t > 0.4 \\Bmsy$. ", refCatSentence, maxCatSentence, sep="")) )
	print(xtabLRP, table.placement="!ht", caption.placement="top",
		add.to.row =list(pos = list(-1), command = c("\\\\[-1.0ex]")) )

	xtabURP = xtable(refProbs$URP, label="tab:URP", digits=tabdigits,
		caption=eval(paste("Decision table",for.area," concerning the upper stock reference point $0.8 \\Bmsy$ for 1-",projYearsNum-1," year projections, such that values are P$(B_t > 0.8 \\Bmsy)$. ", refCatSentence, maxCatSentence, sep="")) )
	print(xtabURP, table.placement="!ht", caption.placement="top",
		add.to.row =list(pos = list(-1), command = c("\\\\[-1.0ex]")) )

	xtabBmsy = xtable(refProbs$Bmsy, label="tab:Bmsy", digits=tabdigits,
		caption=eval(paste("Decision table",for.area," concerning the reference point $\\Bmsy$ for 1-",projYearsNum-1," year projections, such that values are P$(B_t > \\Bmsy)$. ", refCatSentence, maxCatSentence, sep="")) )
	print(xtabBmsy, table.placement="!ht", caption.placement="top",
		add.to.row =list(pos = list(-1), command = c("\\\\[-1.0ex]")) )
	cat(" \\clearpage \\pagebreak ")
}

#=====TABLE: P(Bt>Bcurr) & P(Ut>Ucurr)=====
if (exists("refProbs3GenList") && !is.null(refProbs3GenList$Bcurr)) {
	xtabBcurr = xtable(refProbs3GenList$Bcurr, label="tab:Bcurr", digits=tabdigits, 
		caption=eval(paste("Decision table",for.area," for comparing the projected biomass to the current biomass, given by probabilities P$(B_t > B_{\\currYear})$. ", refCatSentence, maxCatSentence, sep="")) )
	print(xtabBcurr, table.placement="!ht", caption.placement="top",
		add.to.row =list(pos = list(-1), command = c("\\\\[-1.0ex]")) )
}
if (exists("refProbs3GenList.u") && !is.null(refProbs3GenList.u$umsy)) {
	xtabUmsy = xtable(refProbs3GenList.u$umsy, label="tab:umsy", digits=tabdigits,
		caption=eval(paste("Decision table",for.area," for comparing the projected exploitation rate to that at MSY, such that values are P$(u_t > u_\\mathrm{MSY})$, i.e.~the probability of the exploitation rate in the middle of year $t$ being greater than that at MSY. ", refCatSentence, maxCatSentence, sep="")))
	print(xtabUmsy, table.placement="!ht", caption.placement="top",
		add.to.row =list(pos = list(-1), command = c("\\\\[-1.0ex]")) )
	cat(" \\clearpage \\pagebreak ")
}

#=====TABLE: ALTERNATIVE B0 REFERENCE POINTS=====
if (exists("refProbsB010") || exists("refProbsB010")) {
	if (projYearsNum >= 10) {
			refProbsB0 = refProbsB010
	} else {
		refProbsB0 = refProbsB05
	}
}
if (!is.element(spp.name,c("ROL","rol","621"))) {
	if (exists("refProbsB0")) {
		xtabB020 = xtable(refProbsB0$B00.2, label="tab:B0_0.2", digits=tabdigits, 
			caption=eval(paste("Decision table for the alternative limit reference point $0.2 B_0$ for 1-",projYearsNum-1," year projections, such that values are P$(B_t > 0.2 B_0)$. ", refCatSentence, maxCatSentence, sep="")) )
		print(xtabB020, table.placement="!ht", caption.placement="top",
			add.to.row =list(pos = list(-1), command = c("\\\\[-1.0ex]")) )

		xtabB040 = xtable(refProbsB0$B00.4, label="tab:B0_0.4", digits=tabdigits,
			caption=eval(paste("Decision table for the alternative upper stock reference point $0.4 B_0$ for 1-",projYearsNum-1," year projections, such that values are P$(B_t > 0.4 B_0)$. ", refCatSentence, maxCatSentence, sep="")) )
		print(xtabB040, table.placement="!ht", caption.placement="top",
			add.to.row =list(pos = list(-1), command = c("\\\\[-1.0ex]")) )
		cat(" \\clearpage \\pagebreak ")
	}
}
#=====TABLE: ROCK SOLE HISTORICAL REFERENCE POINTS=====
if (is.element(spp.name,c("ROL","rol","621"))) {
	if (projYearsNum >= 10) {
			refProbsHist = refProbsHist10
	} else {
		refProbsHist = refProbsHist5
	}
	# it didn't like \Sexpr in caption="" - need eval(paste
	xtabBlim = xtable(refProbsHist$blimHRP, label="tab:blimHRP", digits=tabdigits,
		caption=eval(paste("Decision table",for.area," concerning the historical limit reference point min($B_{",paste(range(HRP.YRS$blimYrs),collapse="-"),"}$) for 1-",projYearsNum-1," year projections for a range of constant catch strategies (in tonnes). Values are P$(B_t > min(B_{",paste(range(HRP.YRS$blimYrs),collapse="-"),"}))$, i.e.~the probability of the spawning biomass (mature females) at the start of year $t$ being greater than the historical limit reference point. The probabilities are the proportion (to two decimal places) of the ", num.MCMC, " MCMC samples for which $B_t > min(B_{",paste(range(HRP.YRS$blimYrs),collapse="-"),"})$. ", refCatSentence, maxCatSentence, sep="")) )
	print(xtabBlim, table.placement="!ht", caption.placement="top",
		add.to.row =list(pos = list(-1), command = c("\\\\[-1.0ex]")) )

	xtabBtar = xtable(refProbsHist$btarHRP, label="tab:btarHRP", digits=tabdigits,
		caption=eval(paste("Decision table",for.area," concerning the historical target reference point mean($B_{",paste(range(HRP.YRS$btarYrs),collapse="-"),"}$) for 1-",projYearsNum-1," year projections, such that values are P$(B_t > mean(B_{",paste(range(HRP.YRS$btarYrs),collapse="-"),"}))$. ", refCatSentence, maxCatSentence, sep="")) )
	print(xtabBtar, table.placement="!ht", caption.placement="top",
		add.to.row =list(pos = list(-1), command = c("\\\\[-1.0ex]")) )
	cat(" \\clearpage \\pagebreak ")

	if(!is.null(refProbsHistList$ulimHRP)) {
		xtabUlim = xtable(refProbsHistList$ulimHRP, label="tab:ulimHRP", digits=tabdigits,
			caption=eval(paste("Decision table",for.area," concerning the historical limit reference point min($u_{",paste(range(HRP.YRS$ulimYrs),collapse="-"),"}$) for 1-",projYearsNum-1," year projections, such that values are P$(u_t > min(u_{",paste(range(HRP.YRS$ulimYrs),collapse="-"),"}))$. ", refCatSentence, maxCatSentence, sep="")))
		print(xtabUlim, table.placement="!ht", caption.placement="top",
			add.to.row =list(pos = list(-1), command = c("\\\\[-1.0ex]")) )
	}

	if(!is.null(refProbsHistList$utarHRP)) {
		xtabUtar = xtable(refProbsHistList$utarHRP, label="tab:utarHRP", digits=tabdigits,
			caption=eval(paste("Decision table",for.area," concerning the historical target reference point mean($u_{",paste(range(HRP.YRS$utarYrs),collapse="-"),"}$) for 1-",projYearsNum-1," year projections, such that values are P$(u_t > mean(u_{",paste(range(HRP.YRS$utarYrs),collapse="-"),"}))$. ", refCatSentence, maxCatSentence, sep="")))
		print(xtabUtar, table.placement="!ht", caption.placement="top",
			add.to.row =list(pos = list(-1), command = c("\\\\[-1.0ex]")) )
	}
} else { 
	refProbsHist = NULL
}
@

<<savingTables, results=hide, echo=FALSE>>=
# see saving.r in YMR11 for details of tables. Or just look
#  at each one, as they're not that long.  # refProbs3Gen90
save(refProbs, refProbsB0, refProbsHist, refProbs3GenList, refProbs3GenList.u, Ttab0.5, Ttab0.8, Ttab0.95, currentProj, file=paste(model.name, "Tables.RData", sep=""))
@ 

<<savingObjects, results=hide, echo=FALSE>>=
processObj = function(x) {
	if (is.null(dim(x))) return(x)
	else {
		dimx = dim(x); nr=dimx[1]; nc=dimx[2]
		return(x[1:nr,1:nc])
	}
}
Bmcmc <- list()
SA=strsplit(model.name,split="-")  # Species & Area
Bmcmc[[toupper(SA[[1]][1])]][[SA[[1]][2]]] <- list(
	B0.MCMC        = processObj(B0.MCMC),
	Bt.MCMC        = processObj(Bcurr.MCMC),
	Bmsy.MCMC      = processObj(Bmsy.MCMC),
	Blim.MCMC      = processObj(refPointsHistList$blimHRP),
	Btar.MCMC      = processObj(refPointsHistList$btarHRP),
	Utar.MCMC      = processObj(refPointsHistList$utarHRP),
	P.MCMC         = processObj(currentMCMC$P),
	B.MCMC         = processObj(currentMCMC$B),
	R.MCMC         = processObj(currentMCMC$R),
	VB.MCMC        = processObj(currentMCMC$VB),
	U.MCMC         = processObj(currentMCMC$U),
	UoverUmsy.MCMC = processObj(currentMCMC$UoverUmsy),
	BoverBmsy.MCMC = processObj(currentMCMC$BoverBmsy),
	MSY.MCMC       = processObj(msy.MCMC),
	Umsy.MCMC      = processObj(umsy.MCMC)
	)
save("Bmcmc",file=paste("Bmcmc-",model.name,".rda",sep=""))
while(dev.cur() > 1)  dev.off()
@ 

\clearpage
%\section{Bayesian MCMC Results}
@resultsMCMC % RH: Results discussion will be inserted here from the working directory (e.g., from `resultsMCMC-run08.tex`)

%\input{\Sexpr{paste(run.dir, "/../resultsMCMC", sep="")}} # Sexpr don't seem to function when brought in from a separate document. 

\end{document}
%%==============================================================================
% CUT HERE 

# COSEWIC-type Tables. Not needed for POP 3CD and 5DE assessments.
# print(xtable(refProbs3Gen5$'0.5Gen3', caption=eval(paste("NOT CHECKED FROM HERE ONWARDS** Decision table for probabilities of satisfying the criterion of $\\leq 50 \\%$ decline over three generations, for 1-5 year projections for run MODEL.NAME. Three generations is 90 years, and since $B_0$ is the estimated spawning biomass in 1940 and projections here are only up to 5 years, the probabilites here are simply equal to P$(B_t > 0.5 B_0)$. ", refCatSentence, maxCatSentence, sep="")), label="tab:0.5Gen3.5yr", digits=tabdigits), caption.placement="top")
# print(xtable(refProbs3Gen5$'0.7Gen3', caption=eval(paste("Decision table for probabilities of satisfying the criterion of $\\leq 30 \\%$ decline over three generations, for 1-5 year projections for run MODEL.NAME. Three generations is 90 years, and since $B_0$ is the estimated spawning biomass in 1940 and projections here are only up to 5 years, the probabilites here are simply equal to P$(B_t > 0.7 B_0)$. ", refCatSentence, maxCatSentence, sep="")), label="tab:0.7Gen3.5yr", digits=tabdigits), caption.placement="top")
# print(xtable(refProbsB05$B00.5, caption="Decision table for reference point $0.5 B_0$ for 1-5 year projections for run MODEL.NAME, such that values are P$(B_t > 0.5 B_0)$.", label="tab:B00.5.5yr", digits=tabdigits), caption.placement="top")
# print(xtable(refProbsB05$B00.7, caption="Decision table for reference point $0.7 B_0$ for 1-5 year projections for run MODEL.NAME, such that values are P$(B_t > 0.7 B_0)$.", label="tab:B00.7.5yr", digits=tabdigits), caption.placement="top")
# print(xtable(refProbs90$LRP, caption="Decision table for the limit reference point $0.4 \\Bmsy$ for every 15th year (starting from 2011) of 90-year projections for run MODEL.NAME, such that values are P$(B_t > 0.4 \\Bmsy)$.", label="tab:LRP90", digits=tabdigits), caption.placement="top") 
# print(xtable(refProbs90$URP, caption="Decision table for the upper reference point $0.8 \\Bmsy$ for every 15th year of 90-year projections for run MODEL.NAME, such that values are P$(B_t > 0.8 \\Bmsy)$.", label="tab:URP90", digits=tabdigits), caption.placement="top")
# print(xtable(refProbsB090$B00.2, caption="Decision table for the alternative limit reference point $0.2 B_0$ for 90-year projections for run MODEL.NAME, such that values are P$(B_t > 0.2 B_0)$.", label="tab:B00.2.90yr", digits=tabdigits), caption.placement="top")
# print(xtable(refProbsB090$B00.4, caption="Decision table for the alternative upper reference point $0.4 B_0$ for 90-year projections for run MODEL.NAME, such that values are P$(B_t > 0.4 B_0)$.", label="tab:B00.4.90yr", digits=tabdigits), caption.placement="top")
# print(xtable(refProbs3Gen90$'0.5Gen3', caption="Decision table for probabilities of satisfying the criterion of $\\leq 50 \\%$ decline over three generations for 90-year projections for run MODEL.NAME. The probabilites are P$(B_t > 0.5 B_{t-90})$.", label="tab:0.5Gen3.90yr", digits=tabdigits), caption.placement="top")
# print(xtable(refProbs3Gen90$'0.7Gen3', caption="Decision table for probabilities of satisfying the criterion of $\\leq 30 \\%$ decline over three generations for 90-year projections for run MODEL.NAME. The probabilites are P$(B_t > 0.7 B_{t-90})$.", label="tab:0.7Gen3.90yr", digits=tabdigits), caption.placement="top")
# print(xtable(Ttab0.5, caption="Estimated time (years) to be above each reference point or achieve each target with a probability of 50\\%, for each constant catch strategy and for run MODEL.NAME. An estimated time of 0 means that the condition is currently satisfied and remains so over the 90-year projection; an estimated time of 90 means that the condition never becomes satisfied over the 90-year projection. A further condition is that the probability of satisfying the condition must increase for two consecutive years. Columns respectively correspond to reference points $0.4 \\Bmsy, 0.8 \\Bmsy, 0.2 B_0, 0.4 B_0$ and to the criteria of $\\leq 50 \\%$ decline and $\\leq 30 \\%$ decline over three generations.", label="tab:Ttab0.5", digits=0), caption.placement="top")
# print(xtable(Ttab0.8, caption="Estimated time to be above each reference point or achieve each target with a probability of 80\\%, for each constant catch strategy and for run MODEL.NAME. See Table \\ref{tab:Ttab0.5} for column definitions.", label="tab:Ttab0.8", digits=0), caption.placement="top")
# print(xtable(Ttab0.95, caption="Estimated time to be above each reference point or achieve each target with a probability of 95\\%, for each constant catch strategy and for run MODEL.NAME. See Table \\ref{tab:Ttab0.5} for column definitions.", label="tab:Ttab0.95", digits=0), caption.placement="top")
# print(xtable(refProbsB090$B00.5, caption="Decision table for reference point $0.5 B_0$ for 90-year projections for run MODEL.NAME, such that values are P$(B_t > 0.5 B_0)$.", label="tab:B00.5.90yr", digits=tabdigits), caption.placement="top")
# print(xtable(refProbsB090$B00.7, caption="Decision table for reference point $0.7 B_0$ for 90-year projections for run MODEL.NAME, such that values are P$(B_t > 0.7 B_0)$.", label="tab:B00.7.90yr", digits=tabdigits), caption.placement="top")
# print(xtable(refProbs20$LRP, caption="Decision table for the lower reference point $0.4 \\Bmsy$ for every 5th year of 20-year projections for run MODEL.NAME, such that values are P$(B_t > 0.4 \\Bmsy)$.", label="tab:LRP20", digits=tabdigits), caption.placement="top")
# print(xtable(refProbs20$URP, caption="Decision table for the upper reference point $0.8 \\Bmsy$ for every 5th year of 20-year projections for run MODEL.NAME, such that values are P$(B_t > 0.8 \\Bmsy)$.", label="tab:URP20", digits=tabdigits), caption.placement="top")
# print(xtable(refProbs20$Bmsy, caption="Decision table for $\\Bmsy$ for every 5th year of 20-year projections for run MODEL.NAME, such that values are P$(B_t > \\Bmsy)$.", label="tab:Bmsy20", digits=tabdigits), caption.placement="top")
@ 

\clearpage

\section{For Appendix~\thechapter}

\section{BAYESIAN MCMC RESULTS}

The MCMC procedure performed 5,000,000 iterations, sampling every 5,000th to give 1,000 MCMC samples.  The 1,000 samples were used with no burn-in period (because the MCMC searches started from the MPD values).  MCMC traces show good convergence properties (no trend with increasing sample number) for the estimated parameters (Figure \ref{fig:traceParams}), as does a diagnostic analysis that splits the samples into three segments (Figure \ref{fig:splitChain}).  Pairs plots of the estimated parameters (Figures ***-***) show no undesirable correlations between parameters.  In particular, steepness, $h$, and the natural mortality parameters, $M_1$ and $M_2$ (if a two-sex model), show little correlation, suggesting there are sufficient data to estimate them simultaneously.  Trace plots of the derived quantities 'female spawning biomass' (Figure \ref{fig:traceBiomass}) and recruitment (Figure \ref{fig:traceRecruits}) also show good convergence properties.  Thus, the MCMC computations seem satisfactory.

Marginal posterior distributions and corresponding priors for the estimated parameters are shown in Figure \ref{fig:pdfParameters}. For most parameters, it appears that there is enough information in the data to move the posterior distribution away from the prior. The estimates of natural mortality, $M_1$ and $M_2$, did not move too far from their priors, which were based on our previous Queen Charlotte Sound POP assessment \citep{\popQCS}; see Appendix~\eqnchapter. Corresponding summary statistics for the estimated parameters are given in Table \ref{tab:MCMCpar}.

%*** natural mortality bit - change for 5DE.

% Doing selectivity in MPD part now.
% ***TO DO ONCE FIGURE DONE*** The selectivity curves (\ref{fig:selectivityMCMC}) show that......ADAPT from this, which was for YMR: , when estimated, the estimated age at full selectivity for females ($\mu_1$, $\mu_2$ and $\mu_6$ in Figure \ref{fig:selectivityMCMC}) is over 11 years, whereas the prior for these parameters had a mean of 7.2 years (Table F4).  Initial model exploration used informed priors but in the end we used a prior derived from the US commercial fishery on Darkblotched Rockfish for all surveys (or fixed it at such values if selectivity was not estimated) except the QCS shrimp survey (see Appendix D)  The latter used selectivity estimates from a US shelf survey as the fixed parameter values.  

% Marginal posterior densities are also shown for run 'Estimate M' for the annual spawning biomass (Figures G30-G32) and the annual age-1 recruitments (Figures G33-G35).  Some of these show appropriately wide distributions, resulting from the wide distributions shown for some of the estimated parameters (Figure G27).  However, in most instances, the mode of the posterior distribution is very close to the MPD estimates, indicating that the posterior distributions do not appear to be skewed by data outliers.  

Plots of marginal posterior distributions of vulnerable biomass, spawning biomass, annual recruitment and exploitation rate are presented in the main text, because of their interest to management.  Phase plots showing the time-evolution of spawning biomass and exploitation rate relative to reference points are also shown in the main text, together with projections and resulting decision tables.

For the maximum sustainable yield (MSY) calculations, projections were run for \Sexpr{currentMSY$maxUind[1]} values of constant exploitation rate $u_t$ between \Sexpr{currentMSY$uMin[1]} and \Sexpr{currentMSY$uMax[1]}, until an equilibrium yield was reached within a tolerance of \Sexpr{currentMSY$tolerance[1]}~t (or until \Sexpr{prettyNum(currentMSY$maxProj[1], big.mark=",")} years had been reached). This was done for each of the \numMCMC~samples.  % $ 

The lower bound of $u_t$ was reached for \Sexpr{sum(currentMSY$imsy == 1)} of the MCMC samples, and the upper bound for \Sexpr{sum(currentMSY$imsy == currentMSY$maxUind[1])} of the samples. Of the total of \Sexpr{prettyNum(currentMSY$maxUind[1] * num.MCMC, big.mark=",")} projection calculations, \Sexpr{sum(currentMSY$nProjMatTF)} did not convergence by \Sexpr{prettyNum(currentMSY$maxProj[1], big.mark=",")} years.

% End of Appendix F

%\clearpage
%\section{Bayesian MCMC Results}
@resultsMCMC % RH: Results discussion will be inserted here from the working directory (e.g., from `resultsMCMC-run08.tex`)


\section{For main docco}

% From YMR, main docco, MODEL RESULTS to 17 RPA ...:

\section{MODEL RESULTS}

The model run had credible fits to the data, as demonstrated by visual examination of the MPD fits to the data and the patterns of residuals (results in Appendix~\thechapter). The MCMC results showed satisfactory convergence of the MCMC search process (Appendix~\thechapter). Priors and marginal posteriors of the estimated parameters are also given in Appendix~\thechapter, along with the values of the estimated parameters (Table \ref{tab:MCMCpar}). The remaining MCMC results, of more general interest, are given here.

Figure \ref{fig:VBcatch} shows the MCMC results for the vulnerable biomass, together with the reconstructed historical catches, and Figure \ref{fig:BVBnorm} shows the estimated medians of vulnerable and spawning (mature females) biomass relative to their unfished values. (The full MCMC results for spawning biomass are shown later in Figure \ref{fig:Rproj} concerning projections). These demonstrate a slight decline in biomass from 1940 to 1960 with the onset of fishing, followed by a very sharp decline in the 1960s due to the heavy fishing (primarily by foreign fleets). After the cessation of foreign fishing, the stock increased through the 1970s. The stock then declined through the 1980s until the mid-1990s, and has since increased, with median values of relative biomasses returning to the 1980 values (Figure \ref{BVBnorm}). 

Estimates of various quantities of interest are given in Table \ref{tab:MCMCderived}. In particular, the median (and 5-95\% credible interval) for depletion $B_{\Sexpr{currYear}}/B_0$, the ratio of current spawning biomass to the unfished equilibrium level, is \Sexpr{med5.95(Bcurr.MCMC / B0.MCMC, dig=3)}.

The aforementioned stock trajectory is further explained by the estimated recruitments (Figure \ref{fig:recruitsMCMC}). There is lower-than-average recruitment in the early 1970s, which may, together with increased catches, explain the end of the increase in vulnerable biomass seen through the 1970s. There is no clear trend in recruitment, with occasional very good years. Note that although 1977 appears to be a good year for age-1 recruits (spawned in 1976), it is by no means as exceptional as seen in that year for the QCS area 5ABC POP stock (Figure 5 of \citealt{\popQCS}) or the companion assessment for area \other \citep{\otherCite}.  [***Change for 5DE]. Evidence for the largest recruitment events can be seen in the commercial proportions-at-age data (Figures \ref{fig:CAcObsFem} and \ref{fig:CAcObsMale}). Such episodic large recruitment events are characteristic of many rockfish Sebastes populations \citep{lyt02}. 

The estimated exploitation rates (ratio of total catch to the vulnerable biomass in the middle of the year), Figure \ref{fig:exploitMCMC}, peak in the mid-1960s due to the large catches, and peak again (though not as high) in the early 1990s. Exploitation rates have remained relatively low since the mid-1990s, with $u_{\Sexpr{currYear-1}}$, the exploitation rate for \Sexpr{currYear-1}, estimated as \Sexpr{med5.95(upenult.MCMC, dig=3)}.

Estimates of further quantities of interest, such as absolute values of biomass, are also given in Table \ref{tab:MCMCderived}, as well as quantities based on maximum sustainable yield (MSY), discussed below. 

\section{ADVICE FOR MANAGERS}

\subsection{CURRENT STOCK LEVEL}

The estimated median MSY (with 5-95\% credible interval, tonnes) is \Sexpr{med5.95(msy.MCMC, dig=0)}, compared to the average catch over the last \Sexpr{num.recentCatchYears} years (\Sexpr{ as.numeric(names(recentCatch)[1])}-\Sexpr{as.numeric(rev(names(recentCatch))[1])}) of \Sexpr{round(recentCatchMean, dig=0)}~t.

The estimated ratio $B_{\Sexpr{currYear}}/\Bmsy$ of spawning biomass at the start of \Sexpr{currYear} ($B_{\Sexpr{currYear}}$) to the equilibrium spawning biomass (mature females only) that will support the maximum sustainable yield ($\Bmsy$), is \Sexpr{med5.95(Bcurr.MCMC/Bmsy.MCMC, dig=3)}. 

As noted above, the depletion $B_{\Sexpr{currYear}}/B_0$, the ratio of current spawning biomass to the unfished equilibrium level, is \Sexpr{med5.95(Bcurr.MCMC / B0.MCMC, dig=3)}. 

\subsection{REFERENCE POINTS}

**Now also have the extra two tables P($B_t > B_{\currYear}$) and P($u_t > \umsy)$, but haven't written text here for revising 3CD and 5DE Res Docs, just revising the .tex files as used for the working paper. So in future may want to put some of that text back into here and automate. 

Decision tables are presented with respect to two sets of reference points (as determined from consultation with N.~Davis, Groundfish Management Unit, pers.~comm.); see below for rationale for the reference points. Each set is based on either $\Bmsy$ or $B_0$ (the estimated unfished equilibrium spawning biomass). All reference points and the associated probabilities were derived from the posterior distributions of Bayesian output from the model.

As part of the Sustainable Fisheries Framework, \citet{dfo09} suggested provisional reference points to guide management and assess harvest in relation to sustainability. Because reference points for Canadian west coast groundfish species have not yet been specified by policy, the suggested provisional DFO limit and upper stock reference points of $0.4 \Bmsy$ and $0.8 \Bmsy$ have been adopted here. These were the reference points used for the POP stock in QCS \citep{\popQCS}.

The zone below the limit reference point ($0.4 \Bmsy$) is termed the "critical zone" while the zone lying between the two reference points is termed the "cautious zone".  The region above the upper stock reference point ($0.8 \Bmsy$) is termed the ``healthy zone''.  $\Bmsy$ is also reported here as an additional reference point - it 'provides a useful basis for comparing stocks' \citep{rmjb11} when conducting meta-analyses of assessment results. 

Figure \ref{fig:compBmsy} shows the distribution of $B_{\Sexpr{currYear}}/\Bmsy$ relative to the DFO Precautionary Approach provisional reference points of $0.4 \Bmsy$ and $0.8 \Bmsy$. The stock is estimated to be currently above the critical zone with probability P$(B_{\Sexpr{currYear}} > 0.4 \Bmsy) = \Sexpr{round(refProbs$LRP[1,1], dig=3)}$ (first column of Table \ref{tab:LRP}), and in the healthy zone with probability P$(B_{\Sexpr{currYear}} > 0.8 \Bmsy) = \Sexpr{round(refProbs$URP[1,1], dig=3)}$; (first column of Table \ref{tab:URP}). For comparison, Figure \ref{fig:compBmsy} also shows the status of the other two POP stocks.

A second component of the provisional harvest rule of \citet{dfo09} is that, when in the healthy zone, the fishing mortality should be at or below that associated with MSY under equilibrium conditions ($\umsy$), be ramped down when in the cautious zone, and be zero when in the critical zone. Figure \ref{fig:snail} shows the exploitation rate in \Sexpr{currYear-1} relative to that at $\umsy$ (red dot and vertical line). The estimated ratio of $u_{\Sexpr{currYear-1}}/\umsy$ is $\Sexpr{med5.95(upenult.MCMC / umsy.MCMC, dig=3)}$. The probability that the exploitation rate is below that associated with MSY is P$(u_{\Sexpr{currYear-1}} < \umsy) = \Sexpr{round(sum(upenult.MCMC < umsy.MCMC)/num.MCMC, dig=3)}$.

The blue and grey circles in Figure \ref{fig:snail} shows that, based on medians, the stock is estimated to have been in the healthy zone since the start of fishing. The median exploitation rate has been $>\umsy$ for a total of \Sexpr{length(years[ UoverUmsy.med>1])} years, the most recent being \Sexpr{rev(years[ UoverUmsy.med>1])[1]}.  
% *** edit for 5DE
% 'years' also has final year, but doesn't matter here. 

Other agencies and jurisdictions often use 'proxy' reference points that are expressed in terms of $B_0$ rather than $\Bmsy$ (e.g.~\citealt{nzmf07, nzmf11}), because $\Bmsy$ is often poorly estimated as it is dependent on estimated parameters and a consistent fishery. Therefore, the reference points of $0.2 B_0$ and $0.4 B_0$ are also presented here; these are the respective default values used in New Zealand as a 'soft' limit (below which management action needs to be taken) and a 'target' biomass for low productivity stocks (a mean around which the biomass is expected to vary).

% Deleting text from YMR regarding reference criteria

\subsection{PROJECTION RESULTS AND DECISION TABLES}

Projections were made to evaluate the future behaviour of the population under different levels of constant catch, given the model assumptions.  The projections, starting with the biomass at the beginning of \Sexpr{currYear}, were made over a range of constant catch strategies (\Sexpr{min(as.numeric(row.names(refProbs$LRP)))}-\Sexpr{prettyNum(max(as.numeric(row.names(refProbs$LRP))), big.mark=",")}~t) for each of the \numMCMC~MCMC samples in the posterior, generating future biomass trends by assuming random recruitment deviations.  Future recruitments were generated through the stock-recruitment function using recruitment deviations drawn randomly from a lognormal distribution with zero mean and constant standard deviation (see Appendix~\eqnchapter{} for full details). Projections were made for \Sexpr{dim(refProbs$LRP)[2]-1} years, as agreed upon with N.~Davis (pers.~comm.). This time frame was considered as long enough to satisify the 'long-term' requirement of the Request for Science Information and Advice (Appendix A), yet short enough for the projected recruitments to be mainly based on individuals spawned before \Sexpr{currYear} (and hence already estimated by the model).

% **** edit for 5DE ****
Resulting projections of spawning biomass are shown for selected catch strategies (Figure \ref{fig:Bproj}). These suggest that the recent increase in spawning biomass would most likely continue for a catch of 600~t, which is larger than the recent average catch. 

Note that recruitment is drawn from the estimated stock-recruitment curve with lognormal error that has a standard deviation of \Sexpr{sigmaR} and a mean of zero. However, this approach of average recruitment does not accurately simulate the occasional large recruitment events that have occurred for this stock. Figure \ref{fig:Rproj} shows that the median recruitments are much lower than for some of the large recruitment events seen in some years, though this issue appears to be less important than in \citet{ymr}, for which two very large recruitment events appeared to sustain the stock. ***Compare with 5DE also.


Decision tables give the probabilities of the spawning biomass exceeding the reference points in specified years, calculated by counting the proportion of MCMC samples for which the biomass exceeded the given reference point.

Results for the three $\Bmsy$-based reference points are presented in Tables \ref{tab:LRP}-\ref{tab:Bmsy}. For example, the estimated probability that the stock is in the provisional healthy zone in 2017 under a constant catch strategy of 1,000~t is P$(B_{2017} > 0.8 \Bmsy)=\Sexpr{round(refProbs$URP["1000","2017"], dig=3)}$ ('1000' row and '2017' column of Table \ref{tab:URP}). Results for the two $B_0$-based reference points are given in Tables \ref{tab:B0_0.2} and \ref{tab:B0_0.4}.    [ *** example not automated.]



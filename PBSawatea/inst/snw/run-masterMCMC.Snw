% Andy adding in formatting for resDocSty.sty, from master.tex
%  24th Aug 2012.
% From Rowan's run-masterMCMC-rh14aug12.Snw. 
% ymrrun-masterMCMC.Snw - just doing MCMC output (MCMC lines were 
%  commented out in ymrrun-masterMCMC.Snw). AME, 3rd May 2011
% ymrrun5-0.Snw. 5/4/11.
% ymrrun2-5.Snw - from Rowan's run2 output. Fifth reweighting. Also
%  adding in automatic table of parameter values. 28th March 2011
% ymrrun1dos.Snw - automatically plot MPD output from Awatea, using
%  scape. Awatea results.dat file must be in directory above, this
%  one used just for figures. 23rd Feburary 2011

% Wish List
%  Re-organise to have all inputting and re-arranging at the start,
%   and do for run-master.Snw also.



% From resDoc master.tex:
\documentclass[11pt]{book}   
\usepackage{resDocSty}      % Res Doc .sty file

\usepackage{Sweave}   % andy add3ed
% \usepackage{epsfig}  % in .sty file
\usepackage{rotating}    % for sideways table
\usepackage{longtable}
% % \usepackage{placeins}
% % \usepackage{nccmath}
% \usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry} 
% Last is in resDoc.sty


\newcommand{\popQCS}{Edwards-etal:2012pop}
\newcommand{\ymr}{Edwards-etal:2012ymr}
\newcommand{\area}{3CD}    % NOT automated in Sweave, but will
\newcommand{\other}{5DE}   %  be set in master latex file.
\newcommand{\otherCite}{Edwards-etal:20135DE}


% \newcommand{\eb}{\begin{eqnarray}}
% \newcommand{\ee}{\end{eqnarray}}
% \renewcommand{\baselinestretch}{1.0}
\newcommand{\Bmsy}{B_\mathrm{MSY}}
\newcommand{\umsy}{u_\mathrm{MSY}}

% For write up
% \def\AppLet{G}                   % Appendix letter
% \def\StartP{100}                   % page start

% \renewcommand{\theequation}{\AppLet.\arabic{equation}}
% \renewcommand{\thefigure}{\AppLet.\arabic{figure}}

\renewcommand{\rmdefault}{phv}   % Arial
\renewcommand{\sfdefault}{phv}   % Arial


\newcommand\ymrfig[2]{    % filename is #1, text is #2
  \begin{figure}[htp]
  \begin{center}
  \epsfxsize=6in
  \epsfbox{#1.eps}
  \end{center}
  \caption{#2 }
  \label{fig:#1} 
  \end{figure}
  % \clearpage  
}

\newcommand\twofig[3]{    % figure #1 under #2, caption text #3
  \begin{figure}[htp]            %  label will be #1
  \centering
  \begin{tabular}{c}
  \epsfbox{#1.eps} \\
  \epsfbox{#2.eps}
  \end{tabular}
  \caption{#3}
  \label{fig:#1}
  \end{figure}
}

\SweaveOpts{pdf=FALSE}        % keep.source=TRUE, 
% Most useful options (with defaults):
% echo = TRUE  - includes R code in output file
% keep.source = FALSE - when echoing, if TRUE then original source is
%  copied to the file, otherwise deparsed source is echoed.
% eval = TRUE - if FALSE then chunk is not evaluated
% results = verbatim - R output included verbatim, if tex output is 
%  already proper latex and included as is, if hide then all output
%  is completely suppressed (but the code executed - good for admb)
%  Must be lower case (unlike the others!).
% pdf = TRUE - whether .pdf figures shall be generated
% eps = TRUE - whether .eps figures shall be generated
% strip.white = FALSE - if true then blank lines at beginning and
%  end of output are removed. If all, then all blank lines are removed.
% width = 6  - width of figures in inches
% height = 6 - height of figures in inches
% fig = FALSE - whether the code chunk produces graphical output 
%  (only one per chunk)
% \setkeys{Gin}{width=6in}     % from googling sweave figure bigger.
%  It will set this for the rest of document 
%  [doesn't width do that in the above?]

\begin{document}
% \setcounter{page}{\StartP}

\setcounter{secnumdepth}{3}    % To number subsubheadings-ish

\appendix           % Everything from now on will be an Appendix

% Now want to number sections, tables etc. as A.1, A.2, etc.
\renewcommand{\thesection}{\thechapter.\arabic{section}}   
\renewcommand{\thetable}{\thechapter.\arabic{table}}    
\renewcommand{\thefigure}{\thechapter.\arabic{figure}}  
\renewcommand{\theequation}{\thechapter.\arabic{equation}}


% First set up workspace:
<<setupworkspace, echo=FALSE, results=hide>>= # hide the results 
cwd = "@cwd"            # Top level directory; all models occur below this one. 
redo.Graphs=1      # whether to redo the graphs or not (set to 0 if
                   #  just editing the text).
@ 

% '@variables' replaced by function 'runSweave' to create individual Sweaves for runs and reweightings.
<<modelname, echo=FALSE>>=
model.name     = "@model.name"
run.dir        = "@run.dir"
fig.dir        = "@fig.dir"
msy.dir        = "@msy.dir"
prj.dir        = "@prj.dir"
# running.awatea = @running.awatea   # 0 if just loading previous '.rep'; 1 if rerunning Awatea. 
mcsub          = @mcsub
@ 



% \pagestyle{myheadings}
% \markright{\Sexpr{paste("From MCMC", model.name, sep="")}}

\lhead{DRAFT -- Non-citable working paper}  % Omit for final ResDoc.
\rhead{\Sexpr{paste("From MCMC", model.name, sep="")}}
\lfoot{Appendix \thechapter ~-- Model Results} 
\rfoot{Pacific Ocean Perch}  


\chapter{POP 3CD MCMC WORKING RESULTS}

{\bf Andrew M.~Edwards, Rowan Haigh and Paul J.~Starr}

Latest is \today, with \Sexpr{print(version$version.string)}.  % $


Plotting MCMC output for model {\tt \Sexpr{model.name}}. 

We ARE \Sexpr{if(!redo.Graphs) paste("NOT")} replotting the graphs in this run.

*** To Paul/Rowan: The text to go into Appendix G is after the figures and tables. Anything with *** is to be manually done in the final write-up, and I'll manually delete the unnecessary rows of the table of parameter estimtes.  Any ? or ?? are references/citations that will get automatically sorted in the final write up. 

\section{History of Runs}

\input{\Sexpr{paste(run.dir, "/../runHistory", sep="")}}
   % Rowan may wish to replace /../ with cwd (?)

Not fully automated: 

- Table of summary statistics (switches fine if $M_s$ and/or $h$ are fixed/estimated, but won't add extra parameters in (fine for 3CD, will have to tweak for 5DE). 

\medskip

% \noindent Using Run29 and Run30 as 'Estimate $M$' and 'Fix $M$' main runs in YMR write-up, with Run24 and Run28 mentioned in as sensitivites to including simple ageing error.



% For final write-up, need to (at least):
%  manually check things with *** next to them
%  add , into 1000 for 1000 MCMC samples
%  pairs plots - change final caption from 3rd to final, or similar
%  Decision tables - add in the extra headers, as given below
%  Obviously go through and think about the text write up.
%  Number of MCMC iterations below.




<<fromscape, results=hide, echo=FALSE>>=
# Commenting some out for ymr.
#--------------------------------------------------------------------#   AME Commands that are actually run.

# Set style of reconstruction-projection plots.
# Options: "lines", "lineDot", "quantBox"
rpType <- "quantBox"

trellis.device(device="postscript", color=TRUE)   # for colour .eps

# Load in .res file.
setwd(fig.dir) 
#currentRes <- importCol2(paste("../", model.name, ".res", sep=""), 
currentRes = importRes(paste(run.dir,"/", model.name, ".res",sep=""),
             Dev=TRUE, CPUE=TRUE, Survey=TRUE, 
             CLc=TRUE, CLs=TRUE, CAs=TRUE, CAc=TRUE, extra=TRUE)
# maybe should be CPUE=cpue

years = currentRes$B[,"Year"]    
sigmaR = currentRes$extra$residuals$p_log_RecDev[6]
    # to use when importing projected recruitment deviations (that
    #  are actually just the random N(0,1) numbers so need 
    #  multiplying by sigmaR).

# Assign a generic title for use in some plots.
mainTitle <- "@sppname"

# Minimum data year for tuning index.
# minCpueYr <- 1940
#ACH: I'm not sure exactly what this is for but I set it to the start year

# Awatea MCMC.
currentMCMC <- importMCMC( dir=".", quiet=FALSE )
#mpd.P = currentMCMC$P[1,]
#mpd.B = currentMCMC$B[1,]
#mpd.R = currentMCMC$R[1,]
#currentMCMC <- sapply(currentMCMC,function(x,s){x[s,]},s=mcsub,simplify=FALSE)
#assign( "currentMCMC", currentMCMC, pos=1 ) # you do need the assign (maybe because you are jumping from code chunk to code chunk)

#num.MCMC = dim(currentMCMC$P)[1]     # number of MCMC samples
# currentMCMCorig = currentMCMC  
       # to use below
# importMCMC (a scape function) seems to get years wrong on the recruitment, see popScape2.r for details, here is the fix
names(currentMCMC$R) = as.integer(names(currentMCMC$R)) + 1
                                        #currentRes$B$R seems one off
# Also change names of estimated parameters to those matching my
#  write up, and change to the same order. See POPscape2.r .
# **** AME hard-wiring cannot work; RH attempt to fix: ***
#==========================================================
# Get the commercial and survey index series
Cser=unique(currentRes$CPUE$Series);   NCser=length(Cser)
# There has to be a dummy CPUE series in the input, but the 
#  likelihood switch says whether it is being fitted. Seems
#  that the calculated likelihood is 0 if not fitted:
if(currentRes$extra$likelihoods$CPUE == 0) { NCser = 0 }
if(NCser > 1) stop("priorInput construction assumes one CPUE 
  series so needs updating in run-masterMCMC.Snw")

Sser = unique(currentRes$Survey$Series)
Sser = Sser[currentRes$extra$likelihoods$Survey_Index!=0]
NSser= length(Sser)

# Get the commercial and survey age series
# These might also need fixing if there are dummy data that
#  aren't being fitted.
CAser=unique(currentRes$CAc$Series);   NCAser=length(CAser)
SAser=unique(currentRes$CAs$Series);   NSAser=length(SAser)

Ncomm = max(NCser,NCAser) # number of commercial series w/ data/ages
Nsurv = max(NSser,NSAser) # number of survey series with data/ages

Pnames = names(currentMCMC$P)
# can take out paste once get updated PBSawatea.
new.Pnames = gsub("M1_2",paste("M_",2,sep=""),sub("M1_1",paste("M_",1,sep=""),sub("R0","R_0",Pnames)))
for (i in 1:Ncomm) {
	ii = i + Nsurv
	new.Pnames = sub(paste("Sfullest_",i,sep=""),paste("mu_",ii,sep=""),new.Pnames)
	new.Pnames = sub(paste("log_varLest_",i,sep=""),paste("log v_",ii,"L",sep=""),new.Pnames)
	new.Pnames = sub(paste("Sfulldelta_",i,sep=""),paste("Delta_",ii,sep=""),new.Pnames)
	new.Pnames = sub(paste("log_qCPUE_",i,sep=""),paste("log q_",ii,sep=""),new.Pnames)
}
for (i in 1:Nsurv) {
	ii = Sser[i]
	new.Pnames = sub(paste("surveySfull_",i,sep=""),paste("mu_",ii,sep=""),new.Pnames)
	new.Pnames = sub(paste("log_surveyvarL_",i,sep=""),paste("log v_",ii,"L",sep=""),new.Pnames)
	new.Pnames = sub(paste("surveySfulldeltaest_",i,sep=""),paste("Delta_",ii,sep=""),new.Pnames)
	new.Pnames = sub(paste("log_qsurvey_",i,sep=""),paste("log q_",ii,sep=""),new.Pnames)
}
new.Pnames = sub("log_BetaCPUE","log beta",new.Pnames)
# Probably want to change beta, as have beta in write-up already
#  with respect to SR function. And un-log it. Just another q? Think
#  that's already done above - check when doing on a CPUE one. No,
#  I think it's the power for the CPUE.

# Use this if adding extra parameters that are estimated that
#  we haven't thought of here. This is the global list in the
#  desired order. If >5 surveys then expand this, and expand 
#  priorInput function below. 
# log_q should really go to Nsurv+NCser, but will get fixed by
#  use.Pnames.
tab.Pnames = c("R_0","M_1","M_2","h",
  paste("log q_",1:(Nsurv+Ncomm),sep=""),"log beta", 
  paste("mu_",1:(Nsurv+Ncomm),sep=""),
  paste("Delta_",1:(Nsurv+Ncomm),sep=""),
  paste("log v_",1:(Nsurv+Ncomm),"L",sep=""))

# Put them into the standard order:
use.Pnames = tab.Pnames[is.element(tab.Pnames,new.Pnames)]

if(length(use.Pnames) != length(new.Pnames))
  {stop("Check tab.Pnames in run-masterMCMC.Snw")}

# Assign new names
names(currentMCMC$P) = new.Pnames    
# Re-order to match Paul's results table 3:
currentMCMC$P = currentMCMC$P[,use.Pnames]

mpd.P = currentMCMC$P[1,]
mpd.B = currentMCMC$B[1,]
mpd.R = currentMCMC$R[1,]
currentMCMC <- sapply(currentMCMC,function(x,s){x[s,]},s=mcsub,simplify=FALSE)
assign( "currentMCMC", currentMCMC, pos=1 ) # you do need the assign (maybe because you are jumping from code chunk to code chunk)
num.MCMC = dim(currentMCMC$P)[1]     # number of MCMC samples
@

\newcommand{\numMCMC}{\Sexpr{prettyNum(num.MCMC, big.mark=",")}}

<<priors, results=hide, echo=FALSE>>=

# Importing and defining prior functions for general model runs.
#  If change tab.Pnames above then change some of priorInput.

# Unlogging q's at the end

priorFunc = function(input.prior) 
  { switch(as.character(input.prior[4]),
       "0" = function(x, input.prior) { dunif(x, min =
          input.prior[2], max =  input.prior[3]) },
       "1" = function(x, input.prior) { dnorm(x, mean = input.prior[5], sd = input.prior[6]) },
       "2" = stop("figure out lognormal in priorFunc"),
       "5" = function(x, input.prior) { dbeta(x, shape1 = , input.prior[5], shape2 = input.prior[6]) } )
  }

priorInput = array(dim = c(length(use.Pnames), 7))
              # array of priors from the input file, going to put
              #  into the order of use.Pnames
priorDistList = list()      # should be length of use.Pnames
for(i in 1:length(use.Pnames)) 
  {
     ii = use.Pnames[i]
     priorInput[i,] =
     switch(ii,
       # This covers all choices in tab.Pnames
       "R_0" = currentRes$extra$priors$R0,
       "M_1" = currentRes$extra$priors$M1_prior[1,],
       "M_2" = currentRes$extra$priors$M1_prior[2,],            
       "h"   = currentRes$extra$priors$h_prior,              
       # put loop here
       #"log q_1" = currentRes$extra$priors$log_qsurvey_prior[1,],
       "log q_1" = if(Nsurv > 1.9)     # 2 or more surveys
           { currentRes$extra$priors$log_qsurvey_prior[1,] } else
           { currentRes$extra$priors$log_qsurvey_prior },
       "log q_2" = if(Nsurv > 1.9)     # 2 or more surveys
           { currentRes$extra$priors$log_qsurvey_prior[2,] } else
           { currentRes$extra$priors$log_qCPUE_prior },
         # if use.Pnames has q_2 but there's only 1 survey, then
         #  q_2 is the CPUE index catchability. Assuming only
         #  one CPUE index - error message given above if more.
       "log q_3" = if(Nsurv > 2.9)
           { currentRes$extra$priors$log_qsurvey_prior[3,] } else
           { currentRes$extra$priors$log_qCPUE_prior },
       "log q_4" = if(Nsurv > 3.9)
           { currentRes$extra$priors$log_qsurvey_prior[3,] } else
           { currentRes$extra$priors$log_qCPUE_prior },
       "log q_5" = if(Nsurv > 4.9)
           { currentRes$extra$priors$log_qsurvey_prior[3,] } else
           { currentRes$extra$priors$log_qCPUE_prior },
       # assume here max 5 survey series and so CPUE series is 6.
       #  Next line gets ignored if <5 surveys as it won't be
       #  in tab.Pnames anyway (since assuming only 1 CPUE)
       "log q_6" = currentRes$extra$priors$log_qCPUE_prior,
       "log beta" = currentRes$extra$priors$log_BetaCPUE_prior,
       # need loop "mu_1" = currentRes$extra$priors$surveySfull_prior[1,],
       "mu_1" = if(Nsurv > 1.9)
            { currentRes$extra$priors$surveySfull_prior[1,]} else
            { currentRes$extra$priors$surveySfull_prior},
       "mu_2" = if(Nsurv > 1.9)
            { currentRes$extra$priors$surveySfull_prior[2,]} else
            { currentRes$extra$priors$p_Sfullest},
       "mu_3" = if(Nsurv > 2.9)
            { currentRes$extra$priors$surveySfull_prior[3,]} else
            { currentRes$extra$priors$p_Sfullest},
       "mu_4" = if(Nsurv > 3.9)
            { currentRes$extra$priors$surveySfull_prior[4,]} else
            { currentRes$extra$priors$p_Sfullest},
       "mu_5" = if(Nsurv > 4.9)
            { currentRes$extra$priors$surveySfull_prior[5,]} else
            { currentRes$extra$priors$p_Sfullest},
       # Again assume 5 surveys then correct below, this won't get
       #  get called if <5:
       "mu_6" = currentRes$extra$priors$p_Sfullest,
       #"Delta_1" = currentRes$extra$priors$p_surveySfulldelta[1,],
       "Delta_1" = if(Nsurv > 1.9)
            { currentRes$extra$priors$p_surveySfulldelta[1,] } else
            { currentRes$extra$priors$p_surveySfulldelta },
       "Delta_2" = if(Nsurv > 1.9)
            { currentRes$extra$priors$p_surveySfulldelta[2,] } else
            { currentRes$extra$priors$p_Sfulldelta },
       "Delta_3" = if(Nsurv > 2.9)
            { currentRes$extra$priors$p_surveySfulldelta[3,] } else
            { currentRes$extra$priors$p_Sfulldelta },
       "Delta_4" = if(Nsurv > 3.9)
            { currentRes$extra$priors$p_surveySfulldelta[4,] } else
            { currentRes$extra$priors$p_Sfulldelta },
       "Delta_5" = if(Nsurv > 4.9)
            { currentRes$extra$priors$p_surveySfulldelta[5,] } else
            { currentRes$extra$priors$p_Sfulldelta },
       # Again assume 5 surveys.
       "Delta_6" = currentRes$extra$priors$p_Sfulldelta,
       #"log v_1L" = currentRes$extra$priors$log_surveyvarL_prior[1,],
       "log v_1L" = if(Nsurv > 1.9)
            { currentRes$extra$priors$log_surveyvarL_prior[1,] } else
            { currentRes$extra$priors$log_surveyvarL_prior},
       "log v_2L" = if(Nsurv > 1.9)
            { currentRes$extra$priors$log_surveyvarL_prior[2,] } else
            { currentRes$extra$priors$log_varLest_prior},
       "log v_3L" = if(Nsurv > 2.9)
            { currentRes$extra$priors$log_surveyvarL_prior[3,] } else
            { currentRes$extra$priors$log_varLest_prior},
       "log v_4L" = if(Nsurv > 3.9)
            { currentRes$extra$priors$log_surveyvarL_prior[4,] } else
            { currentRes$extra$priors$log_varLest_prior},
       "log v_5L" = if(Nsurv > 4.9)
            { currentRes$extra$priors$log_surveyvarL_prior[5,] } else
            { currentRes$extra$priors$log_varLest_prior},
       # Again assume 5 surveys.
       "log v_6L" = currentRes$extra$priors$log_varLest_prior)
     priorDistList[[i]] = priorFunc(priorInput[i,])
   }
row.names(priorInput) = use.Pnames       
names(priorDistList) = use.Pnames

# confused that after running, those two have q_1 etc. but use.Pnames
#  does not.

# Now going to use q_1, q_2, q_3, not log q_1 etc. So rename
#  and then change values:
qnames = use.Pnames[grep("log q_",use.Pnames)]
for (i in qnames) {
	currentMCMC$P[,i] = exp(currentMCMC$P[,i])
	mpd.P[i] = exp(mpd.P[i])
        # exponentiates the MCMC values
}
names(currentMCMC$P)[is.element(names(currentMCMC$P),qnames)] = substring(qnames,5)
names(mpd.P)[is.element(names(mpd.P),qnames)] = substring(qnames,5)

# Don't need to change tab.Pnames etc. as figures get labelled 
#  automatically from the names in currentMCMC$P

# Need to 'exponentiate' the priors and bounds for q
for(i in qnames) {
  if(priorInput[i,4] != 0) stop("need to exponentiate non-uniform priors for log q, in run-masterMCMC.Snw")
  # otherwise it's uniform.
  # Need to have the bounds exponentiated because the panel.curve
      #  plot uses them automatically to define the range. So change
      #  the priorInput bound values here, and change priorDistList 
      #  to use those because that's what will get called.
  priorInput[i,c(2,3,7)] = exp(priorInput[i,c(2,3,7)])   
                                   # 7 is init cdtn
  priorDistList[[i]] = function(x, input.prior) 
    {   # log x uniform between a and b, then pdf for x is
        #  1/(x (b-a)) between exp(a) and exp(b). Equivalently
        # A = exp(a), B = exp(b) gives pdf for x as
        # 1 /(x (log(B) - log(A)) between A and B
      (x*( log(input.prior[3]) - log(input.prior[2])))^(-1) * ((x >= input.prior[2]) & (x <= input.prior[3] ) ) }
  }  
# And rename priorInput and priorDistList.
row.names(priorInput)[is.element(row.names(priorInput),qnames)] = substring(qnames,5)
names(priorDistList)[is.element(names(priorDistList),qnames)] = substring(qnames,5)


# AME - I'd thought have to fix for beta also, but that's set to 0now
#  I think (had thought it was q, but it's the power).

# End RH fix
#==========================================================

# Deleting lots of commented out code, 20th August 2012.

# Also have to import vulnerable biomass from vulnBiom.pst, as it's
#  not done in importMCMC. Can just do as a data table. Has columns
#  representing years, and each of 1000 rows is an MCMC sample. Same
#  size as currentMCMC$B. It is
#  calculated as denominator of (D.11) in QCS POP model appendix.

vbMCMC = read.table("vulnBiom.pst", header=TRUE)
names(vbMCMC) = names(currentMCMC$B)      # to make them simply years
currentMCMC[["VB"]] = vbMCMC[mcsub,]
       # Add to currentMCMC so that it gets called into functions.

# Awatea projection.
# The importProj function loads a list with elements "B" and "Y" for 
# biomass by catch policy and year, and catch by harvest policy and 
# year.  The "B" element is itself a list of matrices with a matrix 
# for each level of the catch.  This matrix has rows equal to the   
# length of the chain and columns corresponding to projection years.
# There are no [specific - AME] plotting routines for these data.    

# currentProj$eps is a list of data frames, one for each catch
#  strategy, though each data frame is the same (because the same
#  random N(0,1) are used for each one). Each data frame is 1000x91
#  as each row is an MCMC sample and each column is projected year,
#  from 2011 to 2101. For a given MCMC sample, the same random
#  numbers are used for each strategy (but random numbers are
#  different between MCMC samples). i.e.:
# > range(currentProj$eps$'0'[1,] - currentProj$eps$'0'[2,] )
# [1] -2.722770  2.844936
# > range(currentProj$eps$'0'[1,] - currentProj$eps$'250'[1,] )
# [1] 0 0
# So although the eps are the same for each strategy, the actual
#  recruitments won't be because the spawning biomassess will be
#  changing (first year should be the same though).

# currentProj <- importProj( dir=".", quiet=FALSE )

currentProj <- importProjRec( dir=prj.dir, quiet=FALSE )
   # importProjRec includes epsilons for recruitments
   # Then below we calcualte the actual recruitments.

currentProj <- sapply(currentProj,function(X){sapply(X,function(x,s){x[s,]},s=mcsub,simplify=FALSE)},simplify=FALSE)
assign( "currentProj", currentProj, pos=1 )
# Take off final year of projection
currentProj$B = lapply(currentProj$B, function(x) {  x[ ,1:(dim(x)[[2]]-1)]  })
currentProj$Y = lapply(currentProj$Y, function(x) { x[ ,1:(dim(x)[[2]]-1)]  })
currentProj$eps = lapply(currentProj$eps, function(x) {  x[ ,1:(dim(x)[[2]]-1)] })
# currentProj$R is calculated below
# sd(unlist(currentProj$eps$'0'))
# [1] 0.8993165
#  sd(unlist(currentProjaa$eps$'250'))
# [1] 0.8993165
#  etc., as they're all the same, and the sd equals sigmaR.


# Awatea MSY.
currentMSY = msyCalc( dir=msy.dir, error.rep = 0 )  # reports if
    # MSY not converged
# Next line now doesn't work with the scalars in the list, so 
#  replacing with an error for now as we're using all mcsub values
#  for POP 3CD and 5DE.
currentMSY = sapply(currentMSY,function(x,s){x[s]},s=mcsub,simplify=FALSE)       # mcsub subsets the MCMC samples

assign( "currentMSY", currentMSY, pos=1 )      # Forces it global (or something)

# Do these for ease of showing statistics in tables. Each should be a vector with value 
#  for each MCMC draw

if(currentRes$extra$priors$Rinit_prior[1] > 0 & currentRes$extra$priors$Rinit_prior[7] != 1) stop("Not starting from unfished equilibrium, so need to fix B0 values")
B0.MCMC = currentMCMC$B[,1]
# To calculate trajectory for Bt/B0 MCMC's, do:
# BoverB0 = currentMCMC$B / B0.MCMC     # B/B0  each chain
# BoverB0med = apply(BoverB0, 2, median)         # median each year

# AME changing RH's Year to currYearChar
currYearChar = rev(dimnames(currentMCMC$B)[[2]])[1]      
                # character current year (start for projections)
# AME changing RH's Year0 to currYear
currYear = as.numeric(currYearChar)         # numeric current year
startYearChar = dimnames(currentMCMC$B)[[2]][1]   # start year
startYear = as.numeric(startYearChar)

#Ypro  = dimnames(currentProj$B[[1]])[[2]]        # character available projection years
#Ypr0  = as.numeric(Ypro)                         # numeric available projection years

Bcurr.MCMC = currentMCMC$B[,currYearChar]
VB0.MCMC = currentMCMC$VB[,1]
VBcurr.MCMC = currentMCMC$VB[,currYearChar]
Bmsy.MCMC = currentMSY$B
VBmsy.MCMC = currentMSY$VB
msy.MCMC = currentMSY$yield
umsy.MCMC = currentMSY$u


# To calculate the actual projected recruitments (from the eps)
currentProj$R = list()
NN = matrix(1:num.MCMC, nrow=1)      # to use to populate each data.frame
projYearsNames = names(currentProj$B[[1]])
projYearsNum   = length(projYearsNames)

# First calculate recruits for first projection year, which is based
#  on penultimate MCMC year's spawners (which is 2010, final year
#  of that is 2011, first proj year is 2011, and I checked that
#  values for last year of MCMC equal those for first yr of proj:
#  > range(currentMCMC$B[, 72] - currentProj$B$'250'[, 1])
#      0 0.
# Do this here as does not depend on projections (and so is same for
#  all catch strategies).
Bpen.MCMC = currentMCMC$B[, rev(names(currentMCMC$B))[2]]
     # spawning biomass for penultimate year of MCMC


# Need a vector of h for projections, so if h not estimated
#  make hForProj just replicate the mpd value:

if (!is.element("h",use.Pnames))
  {hForProj = rep(currentRes$extra$parameters$h, num.MCMC) } else 
  { hForProj = currentMCMC$P$h }
  
RfirstProj = srFun(Bpen.MCMC, R0 = currentMCMC$P$R_0, h=hForProj, B0=B0.MCMC)

# Stochastic multiplier, will be same for all strategies as random
#  numbers currentProj$eps[[j]] are the same for each strategy j
stochMult = exp(currentProj$eps$'0' - sigmaR^2/2)

for(j in 1:length(currentProj$eps) )    # loop over policies
  {
  junk = apply(NN, 2, function(i, B, R0, h, B0) {
   srFun(as.numeric(B[i,]), h = h[i], R0=R0[i], B0=B0[i] ) },
   B = currentProj$B[[j]],
   R0 = currentMCMC$P$R_0, h = hForProj, B0=B0.MCMC)
       # Rowan's trick for using apply on each row.
  junk = t(junk)
  junk = as.data.frame(junk)
       # This gives data
       #  frame, rows are MCMC samples, columns are recruits for the
       #  next year. Need to insert RfirstProj as first column,
       #  and remove final column (which
       #  corresponds to recruits for the year after final projection
       #  year).
  detR = cbind(RfirstProj, junk)
  detR = detR[, -dim(detR)[2] ]     # take off final column
  names(detR) = projYearsNames      # detR is deterministic values
  stochR = detR * stochMult
  currentProj$R[[j]] = stochR
  }
names(currentProj$R) = names(currentProj$eps)

# Bmsy Reference points (could move this to scape at some point):
# Need 10 year projections for 2012 POP 3CD 5DE assessment. Think
#  the calculations are done automatically (because we specified
#  10 years in the input .txt file), so maybe just have to play
#  with the output.


refPointsList = refPoints()  # ONLY set up for default 0.4, 0.8 
               #  and 1 Bmsy at the moment. See refPointsB0 for B0.
refProbsList = calc.refProbs() # currentMCMC$B, currentProj$B, refPointsList)
# That's a list, each element is the full table for P> LRP, URP or Bmsy, rows are 
#  const catch scenarios and columns are years.
# Full ymr calc is: 
# row.names(temp$LRP)
# [1] "0"    "250"  "500"  "750"  "1000" "1250" "1500" "1750" "2000" "2250"
# [11] "2500" "2750" "3000"
# row.names(t(temp$LRP))    # col.names didn't work?!
#  "2011" "2012" .... "2032"

# Adding in tenYear projections for POP 3CD and 5DE 2012.
# scenarioSubset = c("0", "500", "1000", "1500", "2000" "2250"....
fiveYears   = as.character(currYear+seq(0,5,1))
tenYears    = as.character(currYear+seq(0,10,1))
twentyYears = as.character(currYear+seq(0,20,5))
ninetyYears = as.character(currYear+seq(0,90,15))

refProbs5 = list()    # Probs for 5 years
refProbs10 = list()   # Probs for 10 years
refProbs20 = list()   # Probs for 20 years
refProbs90 = list()   # Probs for 90 years
for(i in 1:length(refProbsList))
	{
	if (projYearsNum>=5) {
		refProbs5[[i]] = refProbsList[[i]][,fiveYears]
		names(refProbs5)[i] = names(refProbsList)[i] }
	if (projYearsNum>=10) {
		refProbs10[[i]] = refProbsList[[i]][,tenYears]
		names(refProbs10)[i] = names(refProbsList)[i] }
        if (projYearsNum>=20) {
		refProbs20[[i]] = refProbsList[[i]][,twentyYears]
		names(refProbs20)[i] = names(refProbsList)[i] }
	if (projYearsNum>=90) {
		refProbs90[[i]] = refProbsList[[i]][,ninetyYears]
		colnames(refProbs90[[i]]) =  as.numeric(colnames(refProbs90[[i]])) - currYear
		names(refProbs90)[i] = names(refProbsList)[i] }
	}

# To check some random values:
# sum( currentProj$B[["1800"]][,"2019"] > 0.4 * Bmsy.MCMC)

# B0 Reference points, not doing moving window here yet 
#  (could move this to scape at some point):

B0refLevels=c(0.2, 0.4, 0.5, 0.7)
B0refNames = paste("B0", B0refLevels, sep="")
refPointsB0List = refPointsB0()     # Above two lines are defaults

refProbsB0List = calc.refProbs(refPlist = refPointsB0List)
# That's a list, each element is the full table for P> each ref point,
#  rows are const catch scenarios and columns are years.
# Check, should get:
# row.names(temp$B00.2)
# [1] "0"    "250"  "500"....
# row.names(t(temp$B00.2))      colnames(...) works
#  "2011" "2012" .... "2101"

# scenarioSubset = c("0", "500", "1000", "1500", "2000" "2250"....

refProbsB05 = list()    # Probs for 5 years
refProbsB010 = list()   # Probs for 10 years
refProbsB020 = list()   # Probs for 20 years
refProbsB090 = list()   # Probs for 90 years
for(i in 1:length(refProbsB0List))
	{
	if (projYearsNum>=5) {
		refProbsB05[[i]] = refProbsB0List[[i]][,fiveYears]
		names(refProbsB05)[i] = names(refProbsB0List)[i] }
	if (projYearsNum>=10) {
		refProbsB010[[i]] = refProbsB0List[[i]][,tenYears]
		names(refProbsB010)[i] = names(refProbsB0List)[i] }
	if (projYearsNum>=20) {
		refProbsB020[[i]] = refProbsB0List[[i]][,twentyYears]
		names(refProbsB020)[i] = names(refProbsB0List)[i] }
	if (projYearsNum>=90) {
		refProbsB090[[i]] = refProbsB0List[[i]][,ninetyYears]
		colnames(refProbsB090[[i]]) =  as.numeric(colnames(refProbsB090[[i]])) - currYear
		names(refProbsB090)[i] = names(refProbsB0List)[i] }
	}
# To give 0, 15 ... as colnames for decision tables
 

# Moving window reference points from Rowan's findTarget.r code,
#  which also calculates 0.4 Bmsy and others.

refProbs3GenList = list()        # Probabilities for decision tables
               #  Will include 0.4Bmsy etc. already calculated above
               #  e.g., refProbs3Gen5$'0.4Bmsy' - refProbs5$LRP  = 0
#list of targets:
Tlst = list(list(ratio=0.4,target=Bmsy.MCMC),
  list(ratio=0.8,target=Bmsy.MCMC),
  list(ratio=0.2,target=B0.MCMC),
  list(ratio=0.4,target=B0.MCMC),
  list(ratio=0.5,target=currentMCMC$B),
  list(ratio=0.7,target=currentMCMC$B))
names(Tlst)=c("0.4Bmsy","0.8Bmsy","0.2B0","0.4B0","0.5Gen3","0.7Gen3")

refProbs3GenList = sapply(Tlst,function(x){sapply(currentProj$B,
  findTarget,ratio=x$ratio,target=x$target,retVal="p.hi")},
  simplify=FALSE)
refProbs3GenList = sapply(refProbs3GenList,t,simplify=FALSE) 
                                        # transpose matrices
refProbs3Gen5 = list()    # Probs for 5 years
refProbs3Gen90 = list()   # Probs for 90 years

for(i in 1:length(refProbs3GenList))
	{
	if (projYearsNum>=5) {
		refProbs3Gen5[[i]] = refProbs3GenList[[i]][,fiveYears]
		names(refProbs3Gen5)[i] = names(refProbs3GenList)[i] }
	if (projYearsNum>=90) {
		refProbs3Gen90[[i]] = refProbs3GenList[[i]][,ninetyYears]
		colnames(refProbs3Gen90[[i]]) =  as.numeric(colnames(refProbs3Gen90[[i]])) - currYear
		names(refProbs3Gen90)[i] = names(refProbs3GenList)[i] }
	}
# To give 0, 15 ... as colnames for decision tables

# Also calculate number of years to reach reference target points
#  with a specified confidence, 0.5, 0.8 and 0.95
Ttab0.5 = sapply(Tlst,function(x){sapply(currentProj$B,findTarget,ratio=x$ratio,target=x$target,conf=0.5,retVal="N")})
Ttab0.8 = sapply(Tlst,function(x){sapply(currentProj$B,findTarget,ratio=x$ratio,target=x$target,conf=0.8,retVal="N")})
Ttab0.95 = sapply(Tlst,function(x){sapply(currentProj$B,findTarget,ratio=x$ratio,target=x$target,conf=0.95,retVal="N")})

# Need to calculate exploitation rates over time for MCMC (MPD's are
#  included in currentRes, but nothing in currentMCMC. Going to add
#  currentMCMC$U to currentMCMC. After doing this realised it was
#  sort of done in popScapeRuns2.r, but only internally for plotting
#  figures.

if(!is.na( currentRes$B$Y[length(currentRes$B$Y)] )) stop("Check
  catch =   and  currentMCMC$U =     in run-masterMCMC.Snw") 
catch = currentRes$B$Y[-length(currentRes$B$Y)]   # take off final NA
names(catch) = years[-length(years)]
   
currentMCMC$U = currentMCMC$VB[,-dim(currentMCMC$VB)[2]] # Don't want final, as no catch; already subset because VB was subset
names.cmu = names(currentMCMC$U)
currentMCMC$U = t(apply(currentMCMC$U, 1, function(x,y){ y/x }, y=catch))    # Need transpose to get right way round again
names(currentMCMC$U) = names.cmu
# So currentMCMC$U is now exploitation rate for MCMC output.

upenult.MCMC = currentMCMC$U[,as.character(currYear-1)]
umax.MCMC = apply(currentMCMC$U, 1, max)

# Catch for last num.recentCatchYears years of data:
num.recentCatchYears = 5

#if( diff(range(rev(catch)[1:2])) > 0.1 ) 
#   { stop("lastFiveCatch in run-masterMCMC.Snw assumes final year 
#       equals penultimate, but this isn't the case here so fix it") }


if( diff(range(rev(catch)[1:2])) < 0.7 )  # for 5DE the 2012
  {                                       #  was set to 2011 rounded 
    recentCatch = rev(rev(catch)[2:(2+num.recentCatchYears-1)])
              # The last num.recentCatchYears without the final year
              #  as have assumed that's not real data
  } else
  {  recentCatch = rev(rev(catch)[1:num.recentCatchYears])
  }

recentCatchMean = mean(recentCatch)
   
# u.MCMC.med = apply(currentMCMC$U, 2, median)  # median for each year
# For snail plots:
currentMCMC$UoverUmsy = apply(currentMCMC$U, 2, function(x,y){ x/y },  y=umsy.MCMC)    # No transpose
UoverUmsy.med = apply(currentMCMC$UoverUmsy, 2, median)
#  qtab(currentMCMC$UoverUmsy[,"2010"], dig=3 )    agrees with values
#   below in the table

currentMCMC$BoverBmsy = apply(currentMCMC$B, 2, function(x,y){ x/y },  y=Bmsy.MCMC)    # No transpose, also agrees with table below
BoverBmsy.med = apply(currentMCMC$BoverBmsy, 2, median)

# Did this to check MPD's closely matched the medians, they more or 
#  less do:
# plot(apply(currentMCMC$U, 2, median))
# points(currentRes$B$U, col="red")

# For SARA need to calculate Z = M+F = M-log(1-u), so have to do for
#  females and males. Work it out for each MCMC draw, then get the 
#  quantiles from the resulting 1000 values. But if M fixed then
#  just have u to worry about.

# Estimate M:
# Z1 = currentMCMC$P[,"M_1"] - log(1 - upenult.MCMC)
# quantile(Z1, p=c(0.05, 0.50, 0.95))
# Z2 = currentMCMC$P[,"M_2"] - log(1 - upenult.MCMC)
# quantile(Z2, p=c(0.05, 0.50, 0.95))

# Fix M, for females (males the same if fixed values the same):
# Z1 = M1.prior[7] - log(1 - upenult.MCMC)
# quantile(Z1, p=c(0.05, 0.50, 0.95))

quantiles = c(0.05, 0.5, 0.95)      # for tables
# Next was for saving to an .RData file to load into 
#  ../../../POPdeterminR/POPdeterminR.r   to run deterministic model.
# First give variable names that match my write up, then save them 
#  all.
# First set are to be used as input, second set as confirmation.
# For YMR, for now commenting out ones from MCMC.

A = max(currentRes$Sel[,"Age"])
T = diff(range(currentRes$B[,"Year"]))+1       # =72
Ct = currentRes$B$Y[-length(currentRes$B$Y)]    # Takes off 2011 value
# years = currentRes$B[,"Year"]    # moving earlier
ages = sort(unique(currentRes$CAc$Age))

selgeqComm = currentRes$Sel[currentRes$Sel$"Series" == "Gear 1",] 
    # comm sel, selgeq4 for POP, presumably woudl be 6 for YMR as
    #  5 surveyrs, so just write Comm
mat = currentRes$Sel[currentRes$Sel$"Series" == "Maturity" &
       currentRes$Sel$"Sex" == "Female",]      # Female maturity
# M1 = currentMCMC$P[1,"M_1"]           # MPD is first line of MCMC
# M2 = currentMCMC$P[1,"M_2"]           # MPD is first line of MCMC
Rt = currentRes$B$R[-length(currentRes$B$R)]   
                                        # Remove final NA for 2011,
Rt.mpd = Rt       # don't think Rt gets used elsewhere, but leave
                  #  it valid just in case.
# For confirmation:
# R0.mpd = currentMCMC$P[1,"R_0"] #Matches numbers from Ro_So_VB.pst,
                                  # but wasn't going to use that 
                                  #  before?
# h.mpd = currentMCMC$P[1,"h"]
Nats.mpd = currentRes$N
ut.mpd = currentRes$B$U[-length(currentRes$B$U)]  
                                  # remove final NA for 2011
Bt.mpd = currentRes$B$SB
B0.mpd = Bt.mpd[1]       #****CHANGE*** if change init cdts.
Vt.mpd = currentRes$B$V
logRecDev.mpd = currentRes$Dev$Annual
# Also equals currentRes$extra$parameters$log_RecDev from Rowan's 'extra' sublist  in currentRes.

# AME deleted lots of commented out code. 20th August 2012.

@ 

<<plottingFigs, results=hide, echo=FALSE>>=
# Moved from above, as now have currentMCMC$U calcs
# plt.idx( currentRes$Survey,main="Survey Indices") # wasn't called 
#  in plt.mpdGraphs. Doing it here spits out SD of standardised 
#  residuals also. May be useful for iterative reweighting?


if(redo.Graphs)
  plt.mcmcGraphs( currentMCMC, currentProj, save=TRUE, 
                 plotPolicies = names(currentProj$Y[1:6]),
                 onePolicy = names(currentProj$Y[2]), 
                 mpd=list(mpd.P=mpd.P, mpd.B=mpd.B, mpd.R=mpd.R) )
              # Change policy options if want other catch policies 
              #  shown. Set up for length(plotPolicies)=6
              # See help for other options.
# close.allWin()
  # }

# function to use for priors in MPD table. Must read in a vector of 
#  length, and outputs it in the format for the table.
ptab = function(xx) 
  { print(paste(c(xx[1], " & [", xx[2], ",", xx[3], "] & ", 
          xx[4], " & [", xx[5], ",", xx[6], "] & ", xx[7]),
          sep="", collapse="")) 
  }
qtab = function(xx.MCMC, dig=0)     # dig is number of dec places
  { print(paste( c( prettyNum(round(quantile(xx.MCMC, 0.05), 
                                  digits=dig), big.mark=","), 
         " & ", prettyNum(round(quantile(xx.MCMC, 0.50), digits=dig),
                                  big.mark=","),
         " & ", prettyNum(round(quantile(xx.MCMC, 0.95), digits=dig),
                                  big.mark=",")), 
         sep="", collapse=""))
  }  

# to give median (5%-95%) to put in text.
med5.95 = function(xx.MCMC, dig=0)     # dig is number of dec places
  { print(paste( c( prettyNum(round(quantile(xx.MCMC, 0.50), digits=dig),
                                  big.mark=","), 
         "~(",  
                    prettyNum(round(quantile(xx.MCMC, 0.05), 
                                  digits=dig), big.mark=","), 
         "-", prettyNum(round(quantile(xx.MCMC, 0.95), digits=dig),
                                  big.mark=","), ")"),
         sep="", collapse=""))
  }  


# For q_i in table, values can vary between runs, so set to number
#  of significant digits. NOT USED, just doing 4 decimal places
#  for all. 
# sapply(signif(x,3), sprintf, fmt="%#.3g")   # try that for 
#  1.3001  to be 1.300.   Haven't played with yet.
qqtab = function(xx.MCMC, dig=3)     # dig is number sig digits
  { print(paste( c( prettyNum(signif(quantile(xx.MCMC, 0.05), 
                                  digits=dig), big.mark=","), 
        " & ", prettyNum(signif(quantile(xx.MCMC, 0.50), digits=dig),
                                  big.mark=","),
        " & ", prettyNum(signif(quantile(xx.MCMC, 0.95), digits=dig),
                                  big.mark=",")), 
         sep="", collapse=""))
  }  



# not saving for YMR for now (don't have all these variables, though
#  just MPDs so don't need MCMC output).  [These were from MCMC's]
# save(A, T, Ct, selgeqComm, mat, M1, M2, Rt, R0.mpd, h.mpd, Nats.mpd, ut.mpd,  Bt.mpd, B0.mpd, Vt.mpd, logRecDev.mpd, file="run23values.RData")
 # 
# save.image(file="run23all.RData")

# See popScape2.r for pairs plots, from:
# Copy and run this for pairs plots        to
# text(currentRes$B$SB, currentRes$B$U, 1:72)


# Want to report the mean of the median recruitments for past and
#  projections.
recMed = apply(currentMCMC$R, 2, median)
meanRecMed = mean(recMed)
# Do for one policy
# recProjMed1500 = apply(currentProj$R$'1500', 2, median)
# meanRecProjMed1500 = mean(recProjMed1500)

# Want to report the year of first age data:
CAfirstYear = min(min(currentRes$CAc$Year), min(currentRes$CAs$Year))
@ 

\ymrfig{traceParams}{MCMC traces for the estimated parameters. Grey lines show the \numMCMC~samples for each parameter, solid lines show the cumulative median (up to that sample), and dashed lines show the cumulative 2.5 and 97.5 quantiles.  Red circles are the MPD estimates. Except for $M_1$ and $M_2$, subscripts 1 to \Sexpr{Nsurv}*** correspond to the fishery-independent surveys ****, and subscript \Sexpr{Nsurv+1}*** to the commercial fishery.}
% Check***

\ymrfig{splitChain}{Diagnostic plot obtained by dividing the MCMC chain of \numMCMC~MCMC samples into three segments, and overplotting the cumulative distributions of the first segment (green), second segment (red) and final segment (blue).}
% overplotting the cumulative distributions, removing the first 100, then plotting the cumulative distributions for samples 101-400 (green), 301-700 (red) and 701-1000 (blue). }

%=======This line will be expanded to accomodate multiple pairs plots=======
\ymrfig{pairs1}{Pairs plot of \numMCMC~MCMC samples for 1$^\text{st}$ six parameters. Numbers are the absolute values of the correlation coefficients.}


% Need a switch here along the lines of
%  # if(length(use.Pnames) > xx)     if not having 3 figures,
%  as plt.mcmcGraphs won't produce pairs2 or pairs3 (and will go
%  up to pairs5). May not be easily generalisable, given
%  Latex will depend on R - but can just comment out or add more in.
% This didn't work, so just do manually.
% <<pairsPlots, results=tex, echo=FALSE>>=
% if(length(use.Pnames) > 6 )
%   { print(paste(" \\ymrfig{pairs2}{Pairs plot for second six parameters.}")) }
% @ 

%\ymrfig{pairs2}{Pairs plot for second set of six parameters.}
%\ymrfig{pairs3}{Pairs plot for third set of six parameters.}

%\ymrfig{pairs3}{Pairs plot of \numMCMC~MCMC samples for third set of parameters.}

% \ymrfig{pairs4}{Pairs plot of \numMCMC~MCMC samples for ** parameters for run.}

% \ymrfig{pairs5}{Pairs plot of \numMCMC~MCMC samples for ** parameters for run.}

\ymrfig{traceBiomass}{MCMC traces for female spawning biomass estimates at five-year intervals.  Note that vertical scales are different for each plot (to show convergence of the MCMC chain, rather than absolute differences in annual values). Grey lines show the \numMCMC~samples for each parameter, solid lines show the cumulative  median (up to that sample), and dashed lines show the cumulative  2.5 and 97.5 quantiles.  Red circles are the MPD estimates.}

\ymrfig{traceRecruits}{MCMC traces for recruitment estimates at five-year intervals. Note that vertical scales are different for each plot (to show convergence of the MCMC chain, rather than absolute differences in annual recruitment). Grey lines show the \numMCMC~samples for each parameter, solid lines show the cumulative  median (up to that sample), and dashed lines show the cumulative  2.5 and 97.5 quantiles.  Red circles are the MPD estimates.}

\ymrfig{pdfParameters}{Marginal posterior densities (thick black curves) and prior density functions (thin blue curves) for the estimated parameters. Vertical lines represent the 2.5, 50 and 97.5 percentiles, and red filled circles are the MPD estimates. [Distributions are hardwired:] For $R_0$ the prior is a uniform distribution on the range [\Sexpr{priorInput["R_0",2]}, \Sexpr{priorInput["R_0",3]}], and is at too low a value to show up on the graph. The priors for $q_g$ are uniform on a log-scale, and so the probability density function is $1/(x(b-a))$ on a linear scale (where $a$ and $b$ are the bounds on the log scale).}
% such that half of the weight of the prior distribution lies $>0.03$ [**for the parameters used in YMR], which is not obvious from the graphs. 

\clearpage

% \ymrfig{selectivityMCMC}{**** Rowan's favourite figure.*** MCMC selectivity figure will go here, haven't calculated yet (started in {\tt plotSelMCMC.r}---- couldn't find that anywhere, so just see prior calculation folder rprogs/POP12/Mprior).}

% Not using these posterior densities now - get most of the info from
%  the boxplots anyway, and these take up several pages.
% \ymrfig{pdfBiomass1}{Marginal posterior densities for beginning year female spawning biomass (1,000 tonnes) for years 1940-1963 for run \Sexpr{model.name}. Horizontal axes are all to same scale. Note that vertical axes are not to the same scale, but each is scaled to the peak of the density; with the area under each curve integrating to 1.0. Vertical lines are 2.5, 50 and 97.5 percentiles, and filled red circle indicates MPD value.  [**Years not generalised yet.]}

% \ymrfig{pdfBiomass2}{As for Figure \ref{fig:pdfBiomass1} for years 1964-1987.}

% \ymrfig{pdfBiomass3}{As for Figure \ref{fig:pdfBiomass1} for years 1988-2011.}

% \ymrfig{pdfBiomass4}{As for Figure \ref{fig:pdfBiomass1} for years 2012-\Sexpr{currYear}.}

% \ymrfig{pdfRecruitment1}{Marginal posterior densities for recruitment for years 1940-1963 for run \Sexpr{model.name}. Horizontal axes are all to same scale, such that large recruitments in certain large years can be seen. Note that vertical axes are not to the same scale, but each is scaled to the peak of the density; areas under each curve will integrate to 1.0. Vertical lines are 2.5, 50 and 97.5 percentiles, and filled red circle indicates MPD value. }

%\ymrfig{pdfRecruitment2}{As for Figure \ref{fig:pdfRecruitment1} for years 1964-1987.}

%\ymrfig{pdfRecruitment3}{As for Figure \ref{fig:pdfRecruitment1} for years 1988-2011.}

%\ymrfig{pdfRecruitment4}{As for Figure \ref{fig:pdfRecruitment1} for years 2012-\Sexpr{currYear-1}.}

% To go into main docco (except summary table to stay in App G).

\ymrfig{VBcatch}{Estimated vulnerable biomass (boxplots) and commercial catch (vertical bars), in tonnes, over time. Boxplots show the 2.5, 25, 50, 75 and 97.5 percentiles from the MCMC results. Catch is shown to compare its magnitude to the estimated vulnerable biomass.}

\ymrfig{BVBnorm}{Changes in $B_t / B_0$ and $V_t / V_0$ (spawning and vulnerable biomass relative to unfished equilibrium levels) over time, shown as the medians of the MCMC posteriors.}

\ymrfig{recruitsMCMC}{Marginal posterior distribution of recruitment in 1,000's of age-1 fish plotted over time. Boxplots show the 2.5, 25, 50, 75 and 97.5 percentiles from the MCMC results. Note that the first year for which there are age data is \Sexpr{CAfirstYear}, and the plus-age class is \Sexpr{A}, such that there are no direct data concerning age-1 fish before \Sexpr{CAfirstYear-A+1}. Also, the final few years have no direct age-data from which to estimate recruitment, because fish are not fully selected until age *** by the commercial vessels or age *** by surveys (using the MCMC median ages of full selectivity for commercial catch, $\mu_{\Sexpr{Nsurv+Ncomm}}$, and survey *** $\mu_{***}$).}


\ymrfig{exploitMCMC}{Marginal posterior distribution of exploitation rate plotted over time. Boxplots show the 2.5, 25, 50, 75 and 97.5 percentiles from the MCMC results.}

% **** ADD in in latex  ****
\begin{figure}[htp]
\begin{center}
\epsfxsize=6in
\epsfbox{selectivityMCMC}
% \epsfbox{"C:/Documents and Settings/edwardsand/My Documents/latex/POP12/POP3CDworkPaper/mainDoc/CompBmsy-POP-(5DE 5ABC 3CD).eps"}
\end{center}
\caption{**Replace figure with Rowan's for write-up; already put into main.tex**. Current status of the three Canadian POP stocks relative to the DFO Precautionary Approach provisional reference points of $0.4 \Bmsy$ and $0.8 \Bmsy$. The stocks are shown from north to south, and $B_t / \Bmsy$ is for $t=\Sexpr{currYear}$ for 5DE \citep{\otherCite} and 3CD (this assessment), and for $t=2011$ for area 5ABC (run `Estimate $M \& h$' from \citealt{\popQCS}). Boxplots show the 5, 25, 50, 75 and 95 percentiles from the MCMC results.}
\label{fig:compBmsy} 
\end{figure}

\ymrfig{snail}{Phase plot through time of the medians of the ratios $B_t / B_\mathrm{MSY}$ (the spawning biomass in year $t$ relative to $B_\mathrm{MSY}$) and $u_t / u_\mathrm{MSY}$ (the exploitation rate in year $t$ relative to $u_\mathrm{MSY}$). Blue filled circle is the starting year (\Sexpr{startYear}). Years then proceed from light grey through to dark grey with the final year (\Sexpr{currYear - 1}) as a filled red circle, and the red lines represent the 10\% and 90\% percentiles of the posterior distributions for the final year. Vertical grey lines indicate the Precautionary Approach provisional limit and upper stock reference points of 0.4$B_\mathrm{MSY}$ and 0.8$B_\mathrm{MSY}$, and horizontal grey line indicates $u_\mathrm{MSY}$.}


\ymrfig{Bproj}{Projected biomass (t) under different constant catch strategies (t); boxplots show the 2.5, 25, 50, 75 and 97.5 percentiles from the MCMC results. For each of the \numMCMC~samples from the MCMC posterior, the model was run forward in time (red, with medians in black) with a constant catch, and recruitment was simulated from the stock-recruitment function with lognormal error (see equation \ref{Rteqn}). For reference, the average catch over the last \Sexpr{num.recentCatchYears} years (\Sexpr{ as.numeric(names(recentCatch)[1])}-\Sexpr{as.numeric(rev(names(recentCatch))[1])}) is \Sexpr{round(recentCatchMean, dig=0)}~t.}



\clearpage 




% Commenting out for WG meeting, plus not so useful for short 
%  projections. Though now doing 10 years, and I think's useful to 
%  raise caution about how the projections are done. 
\ymrfig{Rproj}{Projected recruitments (red) under different constant catch strategies (boxplots show the 2.5, 25, 50, 75 and 97.5 percentiles from the MCMC results; historical recruitments in black).}
% xx = apply(currentProj$R$'0', 2, max)
% summary(xx)
  
% Commenting out for WG meeting, as above.
% \ymrfig{RprojOnePolicy}{Projected recruitments for just ** constant catch strategy (to go into SAR) for run \Sexpr{model.name}~(boxplots show the 2.5, 25, 50, 75 and 97.5 percentiles from the MCMC results). This shows that the random projected recruitments are fairly similar from year-to-year, without the large recruitment events that are seen in the past. While individual MCMC simulations may have occasional large recruitments, this will not happen for a particular year for all MCMC simulations concurrently, which did happen in the past (so, in particular, the lowest estimates of recruitment were still high). The mean of the median historical recruitments is \Sexpr{round(meanRecMed, digits=0)}.}  
%, whereas the mean of the median projected recruitments is *** } 
% xx = apply(currentProj$R$'1500', 2, median)
% mean(xx)   
% yy = apply(currentMCMC$R, 2, median)
% mean(yy)


\clearpage     % to get tables at end

% Want to automate this, best to do by changing the qtab function
%  to print out the whole row (including $q_4$ etc.), and do it
%  only for ones in use.Pnames. Will just then loop around that
%  for length(use.Pnames). For now it gives NA's for ones not
%  being estimated, so putting up to g=4 because that's what
%  we have for POP 3CD (so just simplify when writing up 3CD and 5DE).
\begin{table}[tp]
\centering
\caption{\label{tab:MCMCpar} 
Summary statistics of MCMC results for estimated parameters (defined in Appendix F). Parameter values are: ****[fill this in], then can delete this: Except for $M_1$ and $M_2$, subscripts 1 to \Sexpr{Nsurv}**** correspond to the fishery-independent surveys, and subscript \Sexpr{Nsurv+1}*** to the commercial fishery.****} % Check rows for write-up***
% Fiddling for now, need to generalise. ***
\begin{tabular}{lrrr} 
\hline
Parameter & \multicolumn{3}{c}{Percentile}\\
\cline{2-4}
 & 5\% & 50\% & 95\% \\
\hline 
$R_0$    & \Sexpr{qtab(currentMCMC$P$R_0)} \\
$M _ 1$  & \Sexpr{ if(length(currentMCMC$P$M_1) > 0) qtab(currentMCMC$P$M_1,dig=4) else  print(paste( "- & - & -", collapse = "")) } \\
$M _ 2$  & \Sexpr{ if(length(currentMCMC$P$M_2) > 0) qtab(currentMCMC$P$M_2,dig=4)  else  print(paste( "- & - & -", collapse = "")) } \\
$h$      & \Sexpr{ if(length(currentMCMC$P$h) > 0) qtab(currentMCMC$P$h, dig=3)  else  print(paste( "- & - & -", collapse = "")) } \\
$q_1$      & \Sexpr{qtab(currentMCMC$P$q_1, dig=4)} \\
$q_2$      & \Sexpr{qtab(currentMCMC$P$q_2, dig=4)} \\
$q_3$      & \Sexpr{qtab(currentMCMC$P$q_3, dig=4)} \\
$q_4$      & \Sexpr{ if(length(currentMCMC$P$q_4) > 0) qtab(currentMCMC$P$q_4, dig=4) else  print(paste( "- & - & -", collapse = "")) } \\
% $q_5$      & \Sexpr{qtab(currentMCMC$P$q_5, dig=5)} \\
$\mu_1$    & \Sexpr{qtab(currentMCMC$P$mu_1, dig=1)} \\
$\mu_2$    & \Sexpr{qtab(currentMCMC$P$mu_2, dig=1)} \\
$\mu_3$    & \Sexpr{qtab(currentMCMC$P$mu_3, dig=1)} \\
$\mu_4$    & \Sexpr{qtab(currentMCMC$P$mu_4, dig=1)} \\
$\Delta_1$ & \Sexpr{qtab(currentMCMC$P$Delta_1, dig=2)} \\
$\Delta_2$ & \Sexpr{qtab(currentMCMC$P$Delta_2, dig=2)} \\ 
$\Delta_3$ & \Sexpr{qtab(currentMCMC$P$Delta_3, dig=2)} \\ 
$\Delta_4$ & \Sexpr{qtab(currentMCMC$P$Delta_4, dig=2)} \\
$\log v_{1L}$  & \Sexpr{qtab(currentMCMC$P$"log v_1L", dig=2)} \\
$\log v_{2L}$  & \Sexpr{qtab(currentMCMC$P$"log v_2L", dig=2)} \\
$\log v_{3L}$  & \Sexpr{qtab(currentMCMC$P$"log v_3L", dig=2)} \\
$\log v_{4L}$  & \Sexpr{qtab(currentMCMC$P$"log v_4L", dig=2)} \\
\hline
\end{tabular}	
\end{table}

\clearpage

\begin{table}[tp]
\centering
\caption{\label{tab:MCMCderived} The 5th, 50th and 95th percentiles of MCMC-derived quantities from the \numMCMC~samples of the MCMC posterior. Definitions are: $B_0$ -- unfished equilibrium spawning biomass (mature females), $V_0$ -- unfished equilibrium vulnerable biomass (males and females), $B_{\Sexpr{currYear}}$ -- spawning biomass at the start of $\Sexpr{currYear}$, $V_{\Sexpr{currYear}}$ -- vulnerable biomass in the middle of \Sexpr{currYear}, $u_{\Sexpr{currYear-1}}$ -- exploitation rate (ratio of total catch to vulnerable biomass) in the middle of \Sexpr{currYear-1}, $u_\mathrm{max}$ -- maximum exploitation rate (calculated for each sample as the maximum exploitation rate from 1940-\Sexpr{as.numeric(rev(names(currentMCMC$U[1,]))[1])}), $\Bmsy$ -- equilibrium spawning biomass at MSY (maximum sustainable yield), $u_\mathrm{MSY}$ -- equilibrium exploitation rate at MSY, $V_\mathrm{MSY}$ -- equilibrium vulnerable biomass at MSY. All biomass values (and MSY) are in tonnes. For reference, the average catch over the last \Sexpr{num.recentCatchYears} years (\Sexpr{ as.numeric(names(recentCatch)[1])}-\Sexpr{as.numeric(rev(names(recentCatch))[1])}) is \Sexpr{round(recentCatchMean, dig=0)}~t.}
\begin{tabular}{lrrr} 
\hline
Value & \multicolumn{3}{c}{Percentile}\\
\cline{2-4}
 & 5\% & 50\% & 95\% \\
\hline 
 & & & \\
& \multicolumn{3}{c}{From model output}\\
$B_0$                  & \Sexpr{qtab(B0.MCMC)} \\
$V_0$                  & \Sexpr{qtab(VB0.MCMC)} \\
$B_{\Sexpr{currYear}}$             & \Sexpr{qtab(Bcurr.MCMC)} \\
$V_{\Sexpr{currYear}}$             & \Sexpr{qtab(VBcurr.MCMC)} \\

$B_{\Sexpr{currYear}} / B_0$       & \Sexpr{qtab(Bcurr.MCMC / B0.MCMC, dig=3)} \\
$V_{\Sexpr{currYear}} / V_0$     & \Sexpr{qtab(VBcurr.MCMC / VB0.MCMC, dig=3)} \\

$u_{\Sexpr{currYear-1}}$             & \Sexpr{qtab(upenult.MCMC, dig=3)} \\
$u_\mathrm{max}$       & \Sexpr{qtab(umax.MCMC, dig=3)} \\
\hline
 & & & \\
& \multicolumn{3}{c}{MSY-based quantities}\\
$0.4 B_\mathrm{MSY}$   &  \Sexpr{qtab(0.4*Bmsy.MCMC)} \\
$0.8 B_\mathrm{MSY}$   &  \Sexpr{qtab(0.8*Bmsy.MCMC)} \\
$B_\mathrm{MSY}$       &  \Sexpr{qtab(Bmsy.MCMC)} \\
$B_\mathrm{MSY} / B_0$ &  \Sexpr{qtab(Bmsy.MCMC / B0.MCMC, dig=3)} \\
$B_{\Sexpr{currYear}} / B_\mathrm{MSY}$ & \Sexpr{qtab(Bcurr.MCMC / Bmsy.MCMC, dig=3)} \\

$\mathrm{MSY}$                    & \Sexpr{qtab(msy.MCMC)} \\
$u_\mathrm{MSY}$       & \Sexpr{qtab(umsy.MCMC, dig=3)} \\
$u_{\Sexpr{currYear-1}} / u_\mathrm{MSY}$ & \Sexpr{qtab(upenult.MCMC / umsy.MCMC, dig=3)} \\

$V_\mathrm{MSY}$       & \Sexpr{qtab(VBmsy.MCMC)} \\
$V_\mathrm{MSY} / V_0$ & \Sexpr{qtab(VBmsy.MCMC / VB0.MCMC, dig=3)} \\
\hline
\end{tabular}	
\end{table}

\clearpage

% For Decision table write up **** add something like this to the header:
% \multicolumn{7}{l}{P$(B_t > 0.4 \Bmsy)$} \\
%  \hline
%Annual catch & \multicolumn{6}{c}{Projection year} \\
%\cline{2-7}
%strategy & 2011 & 2012 & 2013 & 2014 & 2015 & 2016 \\


<<tables, results=tex, echo=FALSE>>=
tabdigits = 2      # number of decimal places to give
# print(xtable(refProbs5$LRP, caption=eval(paste("Decision table concerning the limit reference point $0.4 \\Bmsy$ for 1-5 year projections for run ", model.name, " for a range of constant catch strategies (in tonnes). Values are P$(B_t > 0.4 \\Bmsy)$, i.e.~the probability of the spawning biomass at the start of year $t$ being greater than the limit reference point. The probabilities are based on the MCMC posterior distributions of $B_t$ and $\\Bmsy$, and are rounded to two decimal places. For reference, the average catch over the last ", num.recentCatchYears, " years (", as.numeric(names(recentCatch)[1]), "-", as.numeric(rev(names(recentCatch))[1]), ") is ", round(recentCatchMean, dig=0), "~t.", sep="")), label="tab:LRP5", digits=tabdigits), caption.placement="top") 
# it didn't like \Sexpr in caption="" - need eval(paste

# print(xtable(refProbs5$URP, caption=eval(paste("Decision table for the upper reference point $0.8 \\Bmsy$ for 1-5 year projections for run ", model.name, ", such that values are P$(B_t > 0.8 \\Bmsy)$. For reference, the average catch over the last ", num.recentCatchYears, " years (", as.numeric(names(recentCatch)[1]), "-", as.numeric(rev(names(recentCatch))[1]), ") is ", round(recentCatchMean, dig=0), "~t.", sep="")), label="tab:URP5", digits=tabdigits), caption.placement="top")

# print(xtable(refProbs5$Bmsy, caption="Decision table for MSY for 1-5 year projections for run MODEL.NAME, such that values are P$(B_t > \\Bmsy)$.", label="tab:Bmsy5", digits=tabdigits), caption.placement="top")



# print(xtable(refProbs5$URP, caption=eval(paste("Decision table for the upper reference point $0.8 \\Bmsy$ for 1-5 year projections for run ", model.name, ", such that values are P$(B_t > 0.8 \\Bmsy)$. For reference, the average catch over the last ", num.recentCatchYears, " years (", as.numeric(names(recentCatch)[1]), "-", as.numeric(rev(names(recentCatch))[1]), ") is ", round(recentCatchMean, dig=0), "~t.", sep="")), label="tab:URP5", digits=tabdigits), caption.placement="top")

# print(xtable(refProbs5$Bmsy, caption="Decision table for MSY for 1-5 year projections for run MODEL.NAME, such that values are P$(B_t > \\Bmsy)$.", label="tab:Bmsy5", digits=tabdigits), caption.placement="top")


print(xtable(refProbs10$LRP, caption=eval(paste("Decision table concerning the limit reference point $0.4 \\Bmsy$ for 1-10 year projections for a range of constant catch strategies (in tonnes). Values are P$(B_t > 0.4 \\Bmsy)$, i.e.~the probability of the spawning biomass (mature females) at the start of year $t$ being greater than the limit reference point. The probabilities are the proportion (to two decimal places) of the ", num.MCMC, " MCMC samples for which $B_t > 0.4 \\Bmsy$. For reference, the average catch over the last ", num.recentCatchYears, " years (", as.numeric(names(recentCatch)[1]), "-", as.numeric(rev(names(recentCatch))[1]), ") is ", round(recentCatchMean, dig=0), "~t.", sep="")), label="tab:LRP10", digits=tabdigits), caption.placement="top") 
# it didn't like \Sexpr in caption="" - need eval(paste

print(xtable(refProbs10$URP, caption=eval(paste("Decision table for the upper reference point $0.8 \\Bmsy$ for 1-10 year projections, such that values are P$(B_t > 0.8 \\Bmsy)$. For reference, the average catch over the last ", num.recentCatchYears, " years (", as.numeric(names(recentCatch)[1]), "-", as.numeric(rev(names(recentCatch))[1]), ") is ", round(recentCatchMean, dig=0), "~t.", sep="")), label="tab:URP10", digits=tabdigits), caption.placement="top") 

print(xtable(refProbs10$Bmsy, caption=eval(paste("Decision table for the reference point $\\Bmsy$ for 1-10 year projections, such that values are P$(B_t > \\Bmsy)$. For reference, the average catch over the last ", num.recentCatchYears, " years (", as.numeric(names(recentCatch)[1]), "-", as.numeric(rev(names(recentCatch))[1]), ") is ", round(recentCatchMean, dig=0), "~t.", sep="")), label="tab:Bmsy10", digits=tabdigits), caption.placement="top") 




# print(xtable(refProbsB05$B00.2, caption=eval(paste("Decision table for the alternative limit reference point $0.2 B_0$ for 1-5 year projections for run ", model.name, ", such that values are P$(B_t > 0.2 B_0)$. For reference, the average catch over the last ", num.recentCatchYears, " years (", as.numeric(names(recentCatch)[1]), "-", as.numeric(rev(names(recentCatch))[1]), ") is ", round(recentCatchMean, dig=0), "~t.", sep="")), label="tab:B00.2.5yr", digits=tabdigits), caption.placement="top")

# 

# print(xtable(refProbsB05$B00.4, caption=eval(paste("Decision table for the alternative upper reference point $0.4 B_0$ for 1-5 year projections for run ", model.name, " such that values are P$(B_t > 0.4 B_0)$. For reference, the average catch over the last ", num.recentCatchYears, " years (", as.numeric(names(recentCatch)[1]), "-", as.numeric(rev(names(recentCatch))[1]), ") is ", round(recentCatchMean, dig=0), "~t.", sep="")), label="tab:B00.4.5yr", digits=tabdigits), caption.placement="top")

print(xtable(refProbsB010$B00.2, caption=eval(paste("Decision table for the alternative limit reference point $0.2 B_0$ for 1-10 year projections, such that values are P$(B_t > 0.2 B_0)$. For reference, the average catch over the last ", num.recentCatchYears, " years (", as.numeric(names(recentCatch)[1]), "-", as.numeric(rev(names(recentCatch))[1]), ") is ", round(recentCatchMean, dig=0), "~t.", sep="")), label="tab:B00.2.10yr", digits=tabdigits), caption.placement="top")

# 

print(xtable(refProbsB010$B00.4, caption=eval(paste("Decision table for the alternative upper reference point $0.4 B_0$ for 1-10 year projections, such that values are P$(B_t > 0.4 B_0)$. For reference, the average catch over the last ", num.recentCatchYears, " years (", as.numeric(names(recentCatch)[1]), "-", as.numeric(rev(names(recentCatch))[1]), ") is ", round(recentCatchMean, dig=0), "~t.", sep="")), label="tab:B00.4.10yr", digits=tabdigits), caption.placement="top")


# COSEWIC-type Tables. Not needed for POP 3CD and 5DE assessments.
# print(xtable(refProbs3Gen5$'0.5Gen3', caption=eval(paste("NOT CHECKED FROM HERE ONWARDS** Decision table for probabilities of satisfying the criterion of $\\leq 50 \\%$ decline over three generations, for 1-5 year projections for run MODEL.NAME. Three generations is 90 years, and since $B_0$ is the estimated spawning biomass in 1940 and projections here are only up to 5 years, the probabilites here are simply equal to P$(B_t > 0.5 B_0)$. For reference, the average catch over the last ", num.recentCatchYears, " years (", as.numeric(names(recentCatch)[1]), "-", as.numeric(rev(names(recentCatch))[1]), ") is ", round(recentCatchMean, dig=0), "~t.", sep="")), label="tab:0.5Gen3.5yr", digits=tabdigits), caption.placement="top")

# print(xtable(refProbs3Gen5$'0.7Gen3', caption=eval(paste("Decision table for probabilities of satisfying the criterion of $\\leq 30 \\%$ decline over three generations, for 1-5 year projections for run MODEL.NAME. Three generations is 90 years, and since $B_0$ is the estimated spawning biomass in 1940 and projections here are only up to 5 years, the probabilites here are simply equal to P$(B_t > 0.7 B_0)$. For reference, the average catch over the last ", num.recentCatchYears, " years (", as.numeric(names(recentCatch)[1]), "-", as.numeric(rev(names(recentCatch))[1]), ") is ", round(recentCatchMean, dig=0), "~t.", sep="")), label="tab:0.7Gen3.5yr", digits=tabdigits), caption.placement="top")
             
           

# print(xtable(refProbsB05$B00.5, caption="Decision table for reference point $0.5 B_0$ for 1-5 year projections for run MODEL.NAME, such that values are P$(B_t > 0.5 B_0)$.", label="tab:B00.5.5yr", digits=tabdigits), caption.placement="top")

# print(xtable(refProbsB05$B00.7, caption="Decision table for reference point $0.7 B_0$ for 1-5 year projections for run MODEL.NAME, such that values are P$(B_t > 0.7 B_0)$.", label="tab:B00.7.5yr", digits=tabdigits), caption.placement="top")

# print(xtable(refProbs90$LRP, caption="Decision table for the limit reference point $0.4 \\Bmsy$ for every 15th year (starting from 2011) of 90-year projections for run MODEL.NAME, such that values are P$(B_t > 0.4 \\Bmsy)$.", label="tab:LRP90", digits=tabdigits), caption.placement="top") 

# print(xtable(refProbs90$URP, caption="Decision table for the upper reference point $0.8 \\Bmsy$ for every 15th year of 90-year projections for run MODEL.NAME, such that values are P$(B_t > 0.8 \\Bmsy)$.", label="tab:URP90", digits=tabdigits), caption.placement="top")

# print(xtable(refProbsB090$B00.2, caption="Decision table for the alternative limit reference point $0.2 B_0$ for 90-year projections for run MODEL.NAME, such that values are P$(B_t > 0.2 B_0)$.", label="tab:B00.2.90yr", digits=tabdigits), caption.placement="top")

# print(xtable(refProbsB090$B00.4, caption="Decision table for the alternative upper reference point $0.4 B_0$ for 90-year projections for run MODEL.NAME, such that values are P$(B_t > 0.4 B_0)$.", label="tab:B00.4.90yr", digits=tabdigits), caption.placement="top")

# print(xtable(refProbs3Gen90$'0.5Gen3', caption="Decision table for probabilities of satisfying the criterion of $\\leq 50 \\%$ decline over three generations for 90-year projections for run MODEL.NAME. The probabilites are P$(B_t > 0.5 B_{t-90})$.", label="tab:0.5Gen3.90yr", digits=tabdigits), caption.placement="top")

# print(xtable(refProbs3Gen90$'0.7Gen3', caption="Decision table for probabilities of satisfying the criterion of $\\leq 30 \\%$ decline over three generations for 90-year projections for run MODEL.NAME. The probabilites are P$(B_t > 0.7 B_{t-90})$.", label="tab:0.7Gen3.90yr", digits=tabdigits), caption.placement="top")

# print(xtable(Ttab0.5, caption="Estimated time (years) to be above each reference point or achieve each target with a probability of 50\\%, for each constant catch strategy and for run MODEL.NAME. An estimated time of 0 means that the condition is currently satisfied and remains so over the 90-year projection; an estimated time of 90 means that the condition never becomes satisfied over the 90-year projection. A further condition is that the probability of satisfying the condition must increase for two consecutive years. Columns respectively correspond to reference points $0.4 \\Bmsy, 0.8 \\Bmsy, 0.2 B_0, 0.4 B_0$ and to the criteria of $\\leq 50 \\%$ decline and $\\leq 30 \\%$ decline over three generations.", label="tab:Ttab0.5", digits=0), caption.placement="top")

# print(xtable(Ttab0.8, caption="Estimated time to be above each reference point or achieve each target with a probability of 80\\%, for each constant catch strategy and for run MODEL.NAME. See Table \\ref{tab:Ttab0.5} for column definitions.", label="tab:Ttab0.8", digits=0), caption.placement="top")

# print(xtable(Ttab0.95, caption="Estimated time to be above each reference point or achieve each target with a probability of 95\\%, for each constant catch strategy and for run MODEL.NAME. See Table \\ref{tab:Ttab0.5} for column definitions.", label="tab:Ttab0.95", digits=0), caption.placement="top")




# print(xtable(refProbsB090$B00.5, caption="Decision table for reference point $0.5 B_0$ for 90-year projections for run MODEL.NAME, such that values are P$(B_t > 0.5 B_0)$.", label="tab:B00.5.90yr", digits=tabdigits), caption.placement="top")

# print(xtable(refProbsB090$B00.7, caption="Decision table for reference point $0.7 B_0$ for 90-year projections for run MODEL.NAME, such that values are P$(B_t > 0.7 B_0)$.", label="tab:B00.7.90yr", digits=tabdigits), caption.placement="top")




# print(xtable(refProbs20$LRP, caption="Decision table for the lower reference point $0.4 \\Bmsy$ for every 5th year of 20-year projections for run MODEL.NAME, such that values are P$(B_t > 0.4 \\Bmsy)$.", label="tab:LRP20", digits=tabdigits), caption.placement="top")

# print(xtable(refProbs20$URP, caption="Decision table for the upper reference point $0.8 \\Bmsy$ for every 5th year of 20-year projections for run MODEL.NAME, such that values are P$(B_t > 0.8 \\Bmsy)$.", label="tab:URP20", digits=tabdigits), caption.placement="top")

# print(xtable(refProbs20$Bmsy, caption="Decision table for $\\Bmsy$ for every 5th year of 20-year projections for run MODEL.NAME, such that values are P$(B_t > \\Bmsy)$.", label="tab:Bmsy20", digits=tabdigits), caption.placement="top")

@ 


\clearpage

\section{For Appendix G}

\section{BAYESIAN MCMC RESULTS}

The MCMC procedure performed 10,000,000 iterations, sampling every 10,000th to give 1,000 MCMC samples.  The 1,000 samples were used with no burn-in period (because the MCMC searches started from the MPD values).  MCMC traces show good convergence properties (no trend with increasing sample number) for the estimated parameters (Figure \ref{fig:traceParams}), as does a diagnostic analysis that splits the samples into three segments (Figure \ref{fig:splitChain}).  Pairs plots of the estimated parameters (Figures ***-***) show no undesirable correlations between parameters.  In particular, steepness, $h$, and the two natural mortality parameters, $M_1$ and $M_2$, show little correlation, suggesting there are sufficient data to estimate them simultaneously.  Trace plots of the derived quantities 'female spawning biomass' (Figure \ref{fig:traceBiomass}) and recruitment (Figure \ref{fig:traceRecruits}) also show good convergence properties.    Thus, the MCMC computations seem satisfactory.

Marginal posterior distributions and corresponding priors for the estimated parameters are shown in Figure \ref{fig:pdfParameters}. For most parameters, it appears that there is enough information in the data to move the posterior distribution away from the prior. The estimates of natural mortality, $M_1$ and $M_2$, did not move too far from their priors, which were based on our previous Queen Charlotte Sound POP assessment \citep{\popQCS}; see Appendix F. Corresponding summary statistics for the estimated parameters are given in Table \ref{tab:MCMCpar}.

%*** natural mortality bit - change for 5DE.

% Doing selectivity in MPD part now.
***TO DO ONCE FIGURE DONE*** The selectivity curves (\ref{fig:selectivityMCMC}) show that......ADAPT from this, which was for YMR: , when estimated, the estimated age at full selectivity for females ($\mu_1$, $\mu_2$ and $\mu_6$ in Figure \ref{fig:selectivityMCMC}) is over 11 years, whereas the prior for these parameters had a mean of 7.2 years (Table F4).  Initial model exploration used informed priors but in the end we used a prior derived from the US commercial fishery on Darkblotched Rockfish for all surveys (or fixed it at such values if selectivity was not estimated) except the QCS shrimp survey (see Appendix D)  The latter used selectivity estimates from a US shelf survey as the fixed parameter values.  

% Marginal posterior densities are also shown for run 'Estimate M' for the annual spawning biomass (Figures G30-G32) and the annual age-1 recruitments (Figures G33-G35).  Some of these show appropriately wide distributions, resulting from the wide distributions shown for some of the estimated parameters (Figure G27).  However, in most instances, the mode of the posterior distribution is very close to the MPD estimates, indicating that the posterior distributions do not appear to be skewed by data outliers.  

Plots of marginal posterior distributions of vulnerable biomass, spawning biomass, annual recruitment and exploitation rate are presented in the main text, because of their interest to management.  Phase plots showing the time-evolution of spawning biomass and exploitation rate relative to reference points are also shown in the main text, together with projections and resulting decision tables.

For the maximum sustainable yield (MSY) calculations, projections were run for \Sexpr{currentMSY$maxUind[1]} values of constant exploitation rate $u_t$ between \Sexpr{currentMSY$uMin[1]} and \Sexpr{currentMSY$uMax[1]}, until an equilibrium yield was reached within a tolerance of \Sexpr{currentMSY$tolerance[1]}~t (or until \Sexpr{prettyNum(currentMSY$maxProj[1], big.mark=",")} years had been reached). This was done for each of the \numMCMC~samples.  % $ 

The lower bound of $u_t$ was reached for \Sexpr{sum(currentMSY$imsy == 1)} of the MCMC samples, and the upper bound for \Sexpr{sum(currentMSY$imsy == currentMSY$maxUind[1])} of the samples. Of the total of \Sexpr{prettyNum(currentMSY$maxUind[1] * num.MCMC, big.mark=",")} projection calculations, \Sexpr{sum(currentMSY$nProjMatTF)} did not convergence by \Sexpr{prettyNum(currentMSY$maxProj[1], big.mark=",")} years.

% End of Appendix G


\section{For main docco}

% From YMR, main docco, MODEL RESULTS to 17 RPA ...:

\section{MODEL RESULTS}

The model run had credible fits to the data, as demonstrated by visual examination of the MPD fits to the data and the patterns of residuals (results in Appendix G). The MCMC results showed satisfactory convergence of the MCMC search process (Appendix G). Priors and marginal posteriors of the estimated parameters are also given in Appendix G, along with the values of the estimated parameters (Table \ref{tab:MCMCpar}). The remaining MCMC results, of more general interest, are given here.

Figure \ref{fig:VBcatch} shows the MCMC results for the vulnerable biomass, together with the reconstructed historical catches, and Figure \ref{fig:BVBnorm} shows the estimated medians of vulnerable and spawning (mature females) biomass relative to their unfished values. (The full MCMC results for spawning biomass are shown later in Figure \ref{fig:Rproj} concerning projections). These demonstrate a slight decline in biomass from 1940 to 1960 with the onset of fishing, followed by a very sharp decline in the 1960s due to the heavy fishing (primarily by foreign fleets). After the cessation of foreign fishing, the stock increased through the 1970s. The stock then declined through the 1980s until the mid-1990s, and has since increased, with median values of relative biomasses returning to the 1980 values (Figure \ref{BVBnorm}). 

Estimates of various quantities of interest are given in Table \ref{tab:MCMCderived}. In particular, the median (and 5-95\% credible interval) for depletion $B_{\Sexpr{currYear}}/B_0$, the ratio of current spawning biomass to the unfished equilibrium level, is \Sexpr{med5.95(Bcurr.MCMC / B0.MCMC, dig=2)}.

The aforementioned stock trajectory is further explained by the estimated recruitments (Figure \ref{fig:recruitsMCMC}). There is lower-than-average recruitment in the early 1970s, which may, together with increased catches, explain the end of the increase in vulnerable biomass seen through the 1970s. There is no clear trend in recruitment, with occasional very good years. Note that although 1977 appears to be a good year for age-1 recruits (spawned in 1976), it is by no means as exceptional as seen in that year for the QCS area 5ABC POP stock (Figure 5 of \citealt{\popQCS}) or the companion assessment for area \other \citep{\otherCite}.  [***Change for 5DE]. Evidence for the largest recruitment events can be seen in the commercial proportions-at-age data (Figures \ref{fig:CAcObsFem} and \ref{fig:CAcObsMale}). Such episodic large recruitment events are characteristic of many rockfish Sebastes populations \citep{lyt02}. 

The estimated exploitation rates (ratio of total catch to the vulnerable biomass in the middle of the year), Figure \ref{fig:exploitMCMC}, peak in the mid-1960s due to the large catches, and peak again (though not as high) in the early 1990s. Exploitation rates have remained relatively low since the mid-1990s, with $u_{\Sexpr{currYear-1}}$, the exploitation rate for \Sexpr{currYear-1}, estimated as \Sexpr{med5.95(upenult.MCMC, dig=3)}.

Estimates of further quantities of interest, such as absolute values of biomass, are also given in Table \ref{tab:MCMCderived}, as well as quantities based on maximum sustainable yield (MSY), discussed below. 

\section{ADVICE FOR MANAGERS}

\subsection{CURRENT STOCK LEVEL}

The estimated median MSY (with 5-95\% credible interval, tonnes) is \Sexpr{med5.95(msy.MCMC, dig=0)}, compared to the average catch over the last \Sexpr{num.recentCatchYears} years (\Sexpr{ as.numeric(names(recentCatch)[1])}-\Sexpr{as.numeric(rev(names(recentCatch))[1])}) of \Sexpr{round(recentCatchMean, dig=0)}~t.

The estimated ratio $B_{\Sexpr{currYear}}/\Bmsy$ of spawning biomass at the start of \Sexpr{currYear} ($B_{\Sexpr{currYear}}$) to the equilibrium spawning biomass (mature females only) that will support the maximum sustainable yield ($\Bmsy$), is \Sexpr{med5.95(Bcurr.MCMC/Bmsy.MCMC, dig=2)}. 

As noted above, the depletion $B_{\Sexpr{currYear}}/B_0$, the ratio of current spawning biomass to the unfished equilibrium level, is \Sexpr{med5.95(Bcurr.MCMC / B0.MCMC, dig=2)}. 

\subsection{REFERENCE POINTS}

Decision tables are presented with respect to two sets of reference points (as determined from consultation with N.~Davis, Groundfish Management Unit, pers.~comm.); see below for rationale for the reference points. Each set is based on either $\Bmsy$ or $B_0$ (the estimated unfished equilibrium spawning biomass). All reference points and the associated probabilities were derived from the posterior distributions of Bayesian output from the model.

As part of the Sustainable Fisheries Framework, \citet{dfo09} suggested provisional reference points to guide management and assess harvest in relation to sustainability. Because reference points for Canadian west coast groundfish species have not yet been specified by policy, the suggested provisional DFO limit and upper stock reference points of $0.4 \Bmsy$ and $0.8 \Bmsy$ have been adopted here. These were the reference points used for the POP stock in QCS \citep{\popQCS}.

The zone below the limit reference point ($0.4 \Bmsy$) is termed the "critical zone" while the zone lying between the two reference points is termed the "cautious zone".  The region above the upper stock reference point ($0.8 \Bmsy$) is termed the ``healthy zone''.  $\Bmsy$ is also reported here as an additional reference point - it 'provides a useful basis for comparing stocks' \citep{rmjb11} when conducting meta-analyses of assessment results. 

Figure \ref{fig:compBmsy} shows the distribution of $B_{\Sexpr{currYear}}/\Bmsy$ relative to the DFO Precautionary Approach provisional reference points of $0.4 \Bmsy$ and $0.8 \Bmsy$. The stock is estimated to be currently above the critical zone with probability P$(B_{\Sexpr{currYear}} > 0.4 \Bmsy) = \Sexpr{round(refProbs10$LRP[1,1], dig=2)}$ (first column of Table \ref{tab:LRP10}), and in the healthy zone with probability P$(B_{\Sexpr{currYear}} > 0.8 \Bmsy) = \Sexpr{round(refProbs10$URP[1,1], dig=2)}$; (first column of Table \ref{tab:URP10}). For comparison, Figure \ref{fig:compBmsy} also shows the status of the other two POP stocks.

A second component of the provisional harvest rule of \citet{dfo09} is that, when in the healthy zone, the fishing mortality should be at or below that associated with MSY under equilibrium conditions ($\umsy$), be ramped down when in the cautious zone, and be zero when in the critical zone. Figure \ref{fig:snail} shows the exploitation rate in \Sexpr{currYear-1} relative to that at $\umsy$ (red dot and vertical line). The estimated ratio of $u_{\Sexpr{currYear-1}}/\umsy$ is $\Sexpr{med5.95(upenult.MCMC / umsy.MCMC, dig=2)}$. The probability that the exploitation rate is below that associated with MSY is P$(u_{\Sexpr{currYear-1}} < \umsy) = \Sexpr{round(sum(upenult.MCMC < umsy.MCMC)/num.MCMC, dig=2)}$.

The blue and grey circles in Figure \ref{fig:snail} shows that, based on medians, the stock is estimated to have been in the healthy zone since the start of fishing. The median exploitation rate has been $>\umsy$ for a total of \Sexpr{length(years[ UoverUmsy.med>1])} years, the most recent being \Sexpr{rev(years[ UoverUmsy.med>1])[1]}.  
% *** edit for 5DE
% 'years' also has final year, but doesn't matter here. 

Other agencies and jurisdictions often use 'proxy' reference points that are expressed in terms of $B_0$ rather than $\Bmsy$ (e.g.~\citealt{nzmf07, nzmf11}), because $\Bmsy$ is often poorly estimated as it is dependent on estimated parameters and a consistent fishery. Therefore, the reference points of $0.2 B_0$ and $0.4 B_0$ are also presented here; these are the respective default values used in New Zealand as a 'soft' limit (below which management action needs to be taken) and a 'target' biomass for low productivity stocks (a mean around which the biomass is expected to vary).

% Deleting text from YMR regarding reference criteria

\subsection{PROJECTION RESULTS AND DECISION TABLES}

Projections were made to evaluate the future behaviour of the population under different levels of constant catch, given the model assumptions.  The projections, starting with the biomass at the beginning of \Sexpr{currYear}, were made over a range of constant catch strategies (\Sexpr{min(as.numeric(row.names(refProbs10$LRP)))}-\Sexpr{prettyNum(max(as.numeric(row.names(refProbs10$LRP))), big.mark=",")}~t) for each of the \numMCMC~MCMC samples in the posterior, generating future biomass trends by assuming random recruitment deviations.  Future recruitments were generated through the stock-recruitment function using recruitment deviations drawn randomly from a lognormal distribution with zero mean and constant standard deviation (see Appendix F for full details). Projections were made for \Sexpr{dim(refProbs10$LRP)[2]-1} years, as agreed upon with N.~Davis (pers.~comm.). This time frame was considered as long enough to satisify the 'long-term' requirement of the Request for Science Information and Advice (Appendix A), yet short enough for the projected recruitments to be mainly based on individuals spawned before \Sexpr{currYear} (and hence already estimated by the model).

% **** edit for 5DE ****
Resulting projections of spawning biomass are shown for selected catch strategies (Figure \ref{fig:Bproj}). These suggest that the recent increase in spawning biomass would most likely continue for a catch of 600~t, which is larger than the recent average catch. 

Note that recruitment is drawn from the estimated stock-recruitment curve with lognormal error that has a standard deviation of \Sexpr{sigmaR} and a mean of zero. However, this approach of average recruitment does not accurately simulate the occasional large recruitment events that have occurred for this stock. Figure \ref{fig:Rproj} shows that the median recruitments are much lower than for some of the large recruitment events seen in some years, though this issue appears to be less important than in \citet{ymr}, for which two very large recruitment events appeared to sustain the stock. ***Compare with 5DE also.


Decision tables give the probabilities of the spawning biomass exceeding the reference points in specified years, calculated by counting the proportion of MCMC samples for which the biomass exceeded the given reference point.

Results for the three $\Bmsy$-based reference points are presented in Tables \ref{tab:LRP10}-\ref{tab:Bmsy10}. For example, the estimated probability that the stock is in the provisional healthy zone in 2017 under a constant catch strategy of 1,000~t is P$(B_{2017} > 0.8 \Bmsy)=\Sexpr{round(refProbs10$URP["1000","2017"], dig=2)}$ ('1000' row and '2017' column of Table \ref{tab:URP10}). Results for the two $B_0$-based reference points are given in Tables \ref{tab:B00.2.10yr} and \ref{tab:B00.4.10yr}.    [ *** example not automated.]



<<savingTables, results=hide, echo=FALSE>>=
# see saving.r in YMR11 for details of tables. Or just look
#  at each one, as they're not that long.  # refProbs3Gen90
save(refProbs3Gen5, Ttab0.5, Ttab0.8, Ttab0.95,  file=paste(model.name, "Tables.RData", sep=""))
@ 


\end{document}

% CUT HERE 


% ymrrun-masterMCMC20yrProjs.Snw - for 20 year projections. Saving
%  before using 90 as default. 21st June 2011
% ymrrun-masterMCMC.Snw - just doing MCMC output (MCMC lines were 
%  commented out in ymrrun-masterMCMC.Snw). AME, 3rd May 2011
% ymrrun5-0.Snw. 5/4/11.
% ymrrun2-5.Snw - from Rowan's run2 output. Fifth reweighting. Also
%  adding in automatic table of parameter values. 28th March 2011
% ymrrun1dos.Snw - automatically plot MPD output from Awatea, using
%  scape. Awatea results.dat file must be in directory above, this
%  one used just for figures. 23rd Feburary 2011

\documentclass[12pt]{article}

\usepackage{Sweave}   % andy add3ed
\usepackage{epsfig}
\usepackage{rotating}    % for sideways table
\usepackage{longtable}
% \usepackage{placeins}
% \usepackage{nccmath}
\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry} 


\newcommand{\eb}{\begin{eqnarray}}
\newcommand{\ee}{\end{eqnarray}}
\renewcommand{\baselinestretch}{1.0}
\newcommand{\Bmsy}{B_\mathrm{MSY}}

% For write up
\def\AppLet{G}                   % Appendix letter
\def\StartP{100}                   % page start

\renewcommand{\theequation}{\AppLet.\arabic{equation}}
\renewcommand{\thefigure}{\AppLet.\arabic{figure}}

\renewcommand{\rmdefault}{phv}   % Arial
\renewcommand{\sfdefault}{phv}   % Arial


\newcommand\ymrfig[2]{    % filename is #1, text is #2
  \begin{figure}[htp]
  \begin{center}
  \epsfxsize=6in
  \epsfbox{#1.eps}
  \end{center}
  \caption{#2 }
  \label{fig:#1} 
  \end{figure}
  % \clearpage  
}

\newcommand\twofig[3]{    % figure #1 under #2, caption text #3
  \begin{figure}[htp]            %  label will be #1
  \centering
  \begin{tabular}{c}
  \epsfbox{#1.eps} \\
  \epsfbox{#2.eps}
  \end{tabular}
  \caption{#3}
  \label{fig:#1}
  \end{figure}
}

\SweaveOpts{pdf=FALSE}        % keep.source=TRUE, 
% Most useful options (with defaults):
% echo = TRUE  - includes R code in output file
% keep.source = FALSE - when echoing, if TRUE then original source is
%  copied to the file, otherwise deparsed source is echoed.
% eval = TRUE - if FALSE then chunk is not evaluated
% results = VERBATIM - R output included verbatim, if TEX output is 
%  already proper latex and included as is, if HIDE then all output
%  is completely suppressed (but the code executed - good for admb)
% pdf = TRUE - whether .pdf figures shall be generated
% eps = TRUE - whether .eps figures shall be generated
% strip.white = FALSE - if true then blank lines at beginning and
%  end of output are removed. If all, then all blank lines are removed.
% width = 6  - width of figures in inches
% height = 6 - height of figures in inches
% fig = FALSE - whether the code chunk produces graphical output 
%  (only one per chunk)
% \setkeys{Gin}{width=6in}     % from googling sweave figure bigger.
%  It will set this for the rest of document 
%  [doesn't width do that in the above?]

\begin{document}
\setcounter{page}{\StartP}

\begin{center}

{\Large \bf Yellowmouth MCMC working results}

\vspace{7mm}

{\Large \bf Andrew M.~Edwards, Rowan Haigh and Paul J.~Starr}

% This file started 5th April 2011.

Latest is \today, with \Sexpr{print(version$version.string)}. 
% \Sexpr{print(version$platform)}.

% {\tt Andrew.Edwards@dfo-mpo.gc.ca}

% \vspace{4mm}

\end{center}

% First set up workspace:
<<setupworkspace, echo=FALSE, results=hide>>= # hide the results 
# '@variables' replaced by runSweave.
cwd = "@cwd"            # Top level directory; all models occur below this one. 
#rm(list=ls())  
# require(PBSfishery)   # also loads mapping, modelling, data, RODBC
# require(PBSadmb)      # 1st run of these will show package numbers etc.
#require(PBSmodelling)
#require(xtable) 
#require(lattice)
# readADopts()
# Arni Magnusson's support functions for Awatea.
#library(scape)
# Arni Magnusson's support functions for Awatea MCMC.
#library(scapeMCMC)
# Data manipulation functions from CRAN.
#library(gdata)

# Function Definitions 
#source("../../ymrScape.r")
@ 

% '@variables' replaced by function 'runSweave' to create individual Sweaves for runs and reweightings.
<<modelname, echo=FALSE>>=
model.name     = "@model.name"
run.dir        = "@run.dir"
fig.dir        = "@fig.dir"
msy.dir        = "@msy.dir"
running.awatea = @running.awatea   # 0 if just loading previous '.rep'; 1 if rerunning Awatea
@ 
<<awatea.run, results=HIDE, echo = FALSE>>=
if(running.awatea) {
  # makeAD(model.name)
  # runAD(model.name)
  # need to go up a directory, as running Awatea there and doing 
  #  figures here
  #wd = getwd()
  #setwd("..")
  setwd(run.dir)
  shell( paste("awatea -ind ", model.name,".txt -nohess", sep=""))
  #  HAVE to do hess for MCMC
  # shell(     - copy results.dat to results model.name .dat)
  setwd(cwd)     # back to current directory
  } 
@ 

\pagestyle{myheadings}
\markright{\Sexpr{paste("From MCMC", model.name, sep="")}}

Plotting MCMC output for model {\tt \Sexpr{model.name}}. 
% Loading in *****{\tt \Sexpr{model.name}.***} file, that has already been created.

% We {\bf are}~{\bf \Sexpr{if(!running.awatea) paste("NOT")}} re-running Awatea here\Sexpr{if(!running.awatea) paste(" so just loading in outputNOT")}.

% If editing {\tt .txt} file, may have to rerun just in dos/R first to check the output from ADMB (otherwise errors get hidden): 

% {\tt > shell( paste("awatea -ind ../", model.name,".txt -nohess", sep=""))}

\section{History of Runs}

{\tt Run01}: 5 surveys, no CPUE series, initial run with many POP defaults. \newline
\noindent {\tt Run02}: 5 surveys, 1 CPUE series (1977-2010), no tech parameter, dropped 1978 commercial age sample. \newline
\noindent {\tt Run03}: 5 surveys, 1 CPUE series (1977-2010), no tech parameter. \newline
\noindent {\tt Run04}: 5 surveys, 1 CPUE series (1977-95), no tech parameter, selectivities derived from data (naughty). \newline
\noindent {\tt Run05}: 5 surveys, 3 CPUE series (1977-90, 1991-95, 1996-2010), no tech parameter, used Hamel's DBR selectivities to estimate those for YMR. \newline
\noindent {\tt Run06}: 5 surveys, no CPUE series. \newline
\noindent {\tt Run07}: 5 surveys, 1 CPUE series (1977-90), used tech parameter {\tt logBETA}. \newline
\noindent {\tt Run08}: 5 surveys, 2 CPUE series (1977-90, 1991-95), used tech parameter {\tt logBETA}. \newline
\noindent {\tt Run09}: 5 surveys, 1 CPUE series (1977-95), used tech parameter {\tt logBETA}. \newline
\noindent {\tt Run10}: 5 surveys, 1 CPUE series (1983-95), used tech parameter {\tt logBETA}. \newline
\noindent {\tt Run11}: 5 surveys, 1 CPUE series (1977-2010 rollup), used tech parameter {\tt logBETA}, revised selectivities. \newline
\noindent {\tt Run12}: 5 surveys, no CPUE series, revised {\tt varL} to reflect logged values. \newline
\noindent {\tt Run13}: 5 surveys, no CPUE series, made mistake in Run 12 where CPUE {\tt q} turned on. \newline
\noindent {\tt Run14}: 5 surveys, no CPUE series, reweighted using mean ages \`{a} la Francis (2011). \newline
\noindent {\tt Run15}: 5 surveys, no CPUE series, reweighted using mean ages, split {\tt CAc} into regimes brks=c(1979, 1985, 1997, 2004, 2009). \newline
\noindent {\tt Run16}: 5 surveys, no CPUE series, composition reweighted using mean ages (Francis 2011),  abundance CVs w/ added process error 0.2: $c_t = \sqrt{c_o^2 + c_p^2}$.  \newline
\noindent {\tt Run17}: 5 surveys, 1 CPUE series (1977-95 roll-up) with {\tt logBeta}, composition reweighted using mean ages (Francis 2011),  abundance CVs w/ added process error 0.2: $c_t = \sqrt{c_o^2 + c_p^2}$. \newline
\noindent {\tt Run18}: 5 surveys, 1 CPUE series (1977-95 roll-up) with {\tt logBeta}, composition reweighted using mean ages (Francis 2011),  abundance CVs w/ added process error 0.2: $c_t = \sqrt{c_o^2 + c_p^2}$ , SD on M prior changed to 0.01. \newline
\noindent {\tt Run19}: 5 surveys, no CPUE series, Francis reweighting, M prior (0,047, 0.01), {\tt Sfull} SD = $0.3 \mu_g$, no ageing error. \newline
\noindent {\tt Run20}: 5 surveys, no CPUE series, Francis reweighting, M prior (0,047, 0.01), {\tt Sfull} SD = $0.3 \mu_g$, simple symmetric ageing error matrix. \newline
\noindent {\tt Run21}: 5 surveys, no CPUE series, Francis reweighting, M prior (0,047, 0.01), {\tt Sfull} SD = $0.3 \mu_g$, simple symmetric ageing error matrix, tighter {\tt varL} priors. \newline
\noindent {\tt Run22}: 5 surveys, no CPUE series, Francis reweighting, M prior (0,047, 0.005), {\tt Sfull} SD = $0.3 \mu_g$, simple symmetric ageing error matrix, tighter {\tt varL} priors. \newline
\noindent {\tt Run23}: 5 surveys, no CPUE series, Francis reweighting, M fixed at 0.047, {\tt Sfull} SD = $0.3 \mu_g$, simple symmetric ageing error matrix, tighter {\tt varL} priors. \newline
\noindent {\tt Run24}: 5 surveys, no CPUE series, Francis reweighting, M prior (0.047, 0.005), survey selectivities (except shrimp survey) -- priors for {\tt Sfull} ($\mu_g$) and {\tt varL} ($v_{gL}$) set to those for commercial, $\Delta$ for commercial corrected from uniform to normal, simple symmetric ageing error matrix. \newline
\noindent {\tt Run25}: 5 surveys, no CPUE series, Francis reweighting, M prior (0.047, 0.005), selectivity priors as for Run24, symmetric ageing error matrix changed from (0.1, 0.8, 0.1) to (0.2, 0.6, 0.2). \newline
\noindent {\tt Run26}: 5 surveys, no CPUE series, Francis reweighting, M prior (0.047, 0.005), selectivity priors as for Run24, no ageing error.\newline
\noindent {\tt Run27}: 5 surveys, no CPUE series, Francis reweighting, M fixed at 0.047, selectivity priors as for Run24, no ageing error. \newline
\noindent {\tt Run28}: 5 surveys, no CPUE series, Francis reweighting, M fixed at 0.047, selectivity priors as for Run24, symmetric ageing error matrix (0.1, 0.8, 0.1).\newline
\noindent {\tt Run29}: Run26 with Paul's recalculated GIG indices and CVs. \newline
\noindent {\tt Run30}: Run27 with Paul's recalculated GIG indices and CVs.

\medskip

\noindent Using Run29 and Run30 as 'Estimate $M$' and 'Fix $M$' main runs in YMR write-up, with Run24 and Run28 mentioned in as sensitivites to including simple ageing error.

% GOT TO HERE ending for Sweave
% \end{document}
% <<stopping>>=
% stop("GOT TO HERE")
% @ 


<<frompopscape, results=HIDE, echo=FALSE>>=
# Commenting some out for ymr.
#--------------------------------------------------------------------#   AME Commands that are actually run.

# Set style of reconstruction-projection plots.
# Options: "lines", "lineDot", "quantBox"
rpType <- "quantBox"

trellis.device(device="postscript", color=TRUE)   # for colour .eps

# Load in .res file.
setwd(fig.dir) 
#currentRes <- importCol2(paste("../", model.name, ".res", sep=""), 
currentRes = importCol2(paste(run.dir,"/", model.name, ".res", sep=""), 
             Dev=TRUE, CPUE=TRUE, Survey=TRUE, 
             CLc=TRUE, CLs=TRUE, CAs=TRUE, CAc=TRUE, extra=TRUE)

# Assign a generic title for use in some plots.
mainTitle <- "Yellowmouth rockfish"

# Minimum data year for tuning index.
minCpueYr <- 1940
#ACH: I'm not sure exactly what this is for but I set it to the start year

# Set the policy list for projection plots here.
#policy <- c( "0","400","800","1200","1600","2000" )
# Don't think I used for POP
# policy <- c( "0","100","200","300","400","500","600","700",
#              "800","900","1000","1100","1200" )

# Set the reference years and functions for performance measures.
# <deleted - see popScape2.r>

# AME loading in automatically the MCMC and projection file, to
#  save having to do the menus (good for debugging, but presumably
#  will give error if file not there, so need to remove for non-MCMC)

# Awatea MCMC.
currentMCMC <- importMCMC( dir=".", quiet=FALSE )
assign( "currentMCMC", currentMCMC, pos=1 )


currentMCMCorig = currentMCMC  
       # to use below
# importMCMC (a scape function) seems to get years wrong on the recruitment, see popScape2.r for details, here is the fix
names(currentMCMC$R) = as.integer(names(currentMCMC$R)) + 1
                                        #currentRes$B$R seems one off
# Also change names of estimated parameters to those matching my
#  write up, and change to the same order. See POPscape2.r .
# To see defauls given by Awatea do:
#  names(currentMCMCorig$P)
# Will have to do a switch for CPUE. ***** and add extra surveys,
#  Extra surveys not done automatically.
# Need this here to use as a switch for CPUE being estimated or not:
logbetaCPUE.prior = currentRes$extra$priors$log_BetaCPUE
if(logbetaCPUE.prior[1] > 0)       # Then estimating CPUE parameters
  {
    new.Pnames = c("R_0", "h", "M_1", "M_2", "mu_6", "Delta_6", "log v_6L", "log q_6", "log beta", "log q_1", "log q_2", "log q_3", "log q_4", "log q_5", "mu_1", "mu_2", "Delta_1", "Delta_2", "log v_1L", "log v_2L")
  names(currentMCMC$P) = new.Pnames
  # re-order to match Paul's results table 3:
  currentMCMC$P = currentMCMC$P[, c( "R_0",  "M_1", "M_2", "h",
 "log q_1", "log q_2", "log q_3", "log q_4", "log q_5",
 "log q_6", "log beta",
 "mu_1", "mu_2", "mu_6",
 "Delta_1", "Delta_2", "Delta_6",
 "log v_1L", "log v_2L", "log v_6L")]
  # not going to use log for q's or beta  
  currentMCMC$P[,"log q_6"] = exp(currentMCMC$P[,"log q_6"])
  names(currentMCMC$P)[names(currentMCMC$P) == "log q_6"] = "q_6"
  }  else        # no beta or q_6
  {                                
    new.Pnames = c("R_0", "h", "M_1", "M_2", "mu_6", "Delta_6", "log v_6L", "log q_1", "log q_2", "log q_3", "log q_4", "log q_5", "mu_1", "mu_2", "Delta_1", "Delta_2", "log v_1L", "log v_2L")
    names(currentMCMC$P) = new.Pnames
    # re-order to match Paul's results table 3:
    currentMCMC$P = currentMCMC$P[, c( "R_0",  "M_1", "M_2", "h",
 "log q_1", "log q_2", "log q_3", "log q_4", "log q_5",
 "mu_1", "mu_2", "mu_6",
 "Delta_1", "Delta_2", "Delta_6",
 "log v_1L", "log v_2L", "log v_6L")]
  }

# Now going to use q_1, q_2, q_3, not log q_1 etc.
currentMCMC$P[,"log q_1"] = exp(currentMCMC$P[,"log q_1"])
currentMCMC$P[,"log q_2"] = exp(currentMCMC$P[,"log q_2"])
currentMCMC$P[,"log q_3"] = exp(currentMCMC$P[,"log q_3"])
currentMCMC$P[,"log q_4"] = exp(currentMCMC$P[,"log q_4"])
currentMCMC$P[,"log q_5"] = exp(currentMCMC$P[,"log q_5"])

names(currentMCMC$P)[names(currentMCMC$P) == "log q_1"] = "q_1"
names(currentMCMC$P)[names(currentMCMC$P) == "log q_2"] = "q_2"
names(currentMCMC$P)[names(currentMCMC$P) == "log q_3"] = "q_3"
names(currentMCMC$P)[names(currentMCMC$P) == "log q_4"] = "q_4"
names(currentMCMC$P)[names(currentMCMC$P) == "log q_5"] = "q_5"

# Also have to import vulnerable biomass from vulnBiom.pst, as it's
#  not done in importMCMC. Can just do as a data table. Has columns
#  representing years, and each of 1000 rows is an MCMC sample. Same
#  size as currentMCMC$B. It is
#  calculated as denominator of (D.11) in POP model appendix.

vbMCMC = read.table("vulnBiom.pst", header=TRUE)
names(vbMCMC) = names(currentMCMC$B)      # to make them simply years
currentMCMC[["VB"]] = vbMCMC
       # Add to currentMCMC so that it gets called into functions.

# Awatea projection.
# The importProj function loads a list with elements "B" and "Y" for 
# biomass by catch policy and year, and catch by harvest policy and 
# year.  The "B" element is itself a list of matrices with a matrix 
# for each level of the catch.  This matrix has rows equal to the   
# length of the chain and columns corresponding to projection years.
# There are no [specific - AME] plotting routines for these data.                    
currentProj <- importProj( dir=".", quiet=FALSE )
assign( "currentProj", currentProj, pos=1 )
# Take off "2032":
currentProj$B = lapply(currentProj$B, function(x) { x[ , names(x) != "2032"] })
currentProj$Y = lapply(currentProj$Y, function(x) { x[ , names(x) != "2032"] })


# Awatea MSY.
currentMSY <- msyCalc( dir=msy.dir, error.rep = 0 )
assign( "currentMSY", currentMSY, pos=1 )      # Forces it global (or something)

# Do these for ease of showing statistics in tables. Each should be a vector with value 
#  for each MCMC draw
B0.MCMC = currentMCMC$B[,1]
# To calculate trajectory for Bt/B0 MCMC's, do:
# BoverB0 = currentMCMC$B / B0.MCMC     # B/B0  each chain
# BoverB0med = apply(BoverB0, 2, median)         # median each year

B2011.MCMC = currentMCMC$B[,"2011"]
VB0.MCMC = currentMCMC$VB[,1]
VB2011.MCMC = currentMCMC$VB[,"2011"]
Bmsy.MCMC = currentMSY$B
VBmsy.MCMC = currentMSY$VB
msy.MCMC = currentMSY$yield
umsy.MCMC = currentMSY$u


# Bmsy Reference points (could move this to scape at some point):

refPointsList = refPoints()  # ONLY set up for default 0.4, 0.8 
                    #  and 1 Bmsy at the moment *****
refProbsList = calc.refProbs() # currentMCMC$B, currentProj$B, refPointsList)
# That's a list, each element is the full table for P> LRP, URP or Bmsy, rows are 
#  const catch scenarios and columns are years.
# Full ymr calc is: 
# row.names(temp$LRP)
# [1] "0"    "250"  "500"  "750"  "1000" "1250" "1500" "1750" "2000" "2250"
# [11] "2500" "2750" "3000"
# row.names(t(temp$LRP))    # col.names didn't work?!
#  "2011" "2012" .... "2032"

# scenarioSubset = c("0", "500", "1000", "1500", "2000" "2250"....
fiveYears = c("2011", "2012", "2013", "2014", "2015", "2016")
twentyYears = c( "2011", "2016", "2021", "2026", "2031")

refProbs5 = list()    # Probs for 5 years
refProbs20 = list()   # Probs for 20 years
for(i in 1:length(refProbsList))
  {
    refProbs5[[i]] = refProbsList[[i]][,fiveYears]
    refProbs20[[i]] = refProbsList[[i]][,twentyYears]
  }
names(refProbs5)= names(refProbsList)
names(refProbs20)= names(refProbsList)


# B0 Reference points, not doing moving window here yet 
#  (could move this to scape at some point):

B0refLevels=c(0.2, 0.4, 0.5, 0.7)
B0refNames = paste("B0", B0refLevels, sep="")
refPointsB0List = refPointsB0()     # Above two lines are defaults

refProbsB0List = calc.refProbs(refPlist = refPointsB0List)
# That's a list, each element is the full table for P> each ref point,
#  rows are const catch scenarios and columns are years.
# Check, should get:
# row.names(temp$B00.2)
# [1] "0"    "250"  "500"  "750"  "1000" "1250" "1500" "1750" "2000" "2250"
# [11] "2500" "2750" "3000"
# row.names(t(temp$B00.2))
#  "2011" "2012" .... "2032"   2031?

# scenarioSubset = c("0", "500", "1000", "1500", "2000" "2250"....
fiveYears = c("2011", "2012", "2013", "2014", "2015", "2016")
twentyYears = c( "2011", "2016", "2021", "2026", "2031")

refProbsB05 = list()    # Probs for 5 years
refProbsB020 = list()   # Probs for 20 years
for(i in 1:length(refProbsB0List))
  {
    refProbsB05[[i]] = refProbsB0List[[i]][,fiveYears]
    refProbsB020[[i]] = refProbsB0List[[i]][,twentyYears]
  }
names(refProbsB05)= names(refProbsB0List)
names(refProbsB020)= names(refProbsB0List)


# Need to calculate exploitation rates over time for MCMC (MPD's are
#  included in currentRes, but nothing in currentMCMC. Going to add
#  currentMCMC$U to currentMCMC. After doing this realised it was
#  sort of done in popScapeRuns2.r, but only internally for plotting
#  figures.

catch = currentRes$B$Y[-length(currentRes$B$Y)]   # take off 2011 NA

currentMCMC$U = currentMCMC$VB[,-dim(currentMCMC$VB)[2]] # Don't want                                        # 2011, as no catch
names.cmu = names(currentMCMC$U)
currentMCMC$U = t(apply(currentMCMC$U, 1, function(x,y){ y/x }, 
    y=catch))    # Need transpose to get right way round again
names(currentMCMC$U) = names.cmu 
# So currentMCMC$U is now exploitation rate for MCMC output.
u2010.MCMC = currentMCMC$U[,"2010"]
umax.MCMC = apply(currentMCMC$U, 1, max)

# u.MCMC.med = apply(currentMCMC$U, 2, median)  # median for each year
# For snail plots:
currentMCMC$UoverUmsy = apply(currentMCMC$U, 2, function(x,y){ x/y },  y=umsy.MCMC)    # No transpose
UoverUmsy.med = apply(currentMCMC$UoverUmsy, 2, median)
#  qtab(currentMCMC$UoverUmsy[,"2010"], dig=3 )    agrees with values
#   below in the table

currentMCMC$BoverBmsy = apply(currentMCMC$B, 2, function(x,y){ x/y },  y=Bmsy.MCMC)    # No transpose, also agrees with table below
BoverBmsy.med = apply(currentMCMC$BoverBmsy, 2, median)



# Did this to check MPD's closely matched the medians, they more or 
#  less do:
# plot(apply(currentMCMC$U, 2, median))
# points(currentRes$B$U, col="red")

# For SARA need to calculate Z = M+F = M-log(1-u), so have to do for
#  females and males. Work it out for each MCMC draw, then get the 
#  quantiles from the resulting 1000 values. But if M fixed then
#  just have u to worry about.

# Estimate M:
# Z1 = currentMCMC$P[,"M_1"] - log(1 - u2010.MCMC)
# quantile(Z1, p=c(0.05, 0.50, 0.95))
# Z2 = currentMCMC$P[,"M_2"] - log(1 - u2010.MCMC)
# quantile(Z2, p=c(0.05, 0.50, 0.95))

# Fix M, for females (males the same if fixed values the same):
# Z1 = M1.prior[7] - log(1 - u2010.MCMC)
# quantile(Z1, p=c(0.05, 0.50, 0.95))



quantiles = c(0.05, 0.5, 0.95)      # for tables
# Next was for saving to an .RData file to load into 
#  ../../../POPdeterminR/POPdeterminR.r   to run deterministic model.
# First give variable names that match my write up, then save them 
#  all.
# First set are to be used as input, second set as confirmation.
# For YMR, for now commenting out ones from MCMC.

A = max(currentRes$Sel[,"Age"])
T = diff(range(currentRes$B[,"Year"]))+1       # =72
Ct = currentRes$B$Y[-length(currentRes$B$Y)]    # Takes off 2011 value
years = currentRes$B[,"Year"]
ages = sort(unique(currentRes$CAc$Age))

selgeqComm = currentRes$Sel[currentRes$Sel$"Series" == "Gear 1",] 
    # comm sel, selgeq4 for POP, presumably woudl be 6 for YMR as
    #  5 surveyrs, so just write Comm
mat = currentRes$Sel[currentRes$Sel$"Series" == "Maturity" &
       currentRes$Sel$"Sex" == "Female",]      # Female maturity
# M1 = currentMCMC$P[1,"M_1"]           # MPD is first line of MCMC
# M2 = currentMCMC$P[1,"M_2"]           # MPD is first line of MCMC
Rt = currentRes$B$R[-length(currentRes$B$R)]   
                                        # Remove final NA for 2011,

# For confirmation:
# R0.mpd = currentMCMC$P[1,"R_0"] #Matches numbers from Ro_So_VB.pst,
                                  # but wasn't going to use that 
                                  #  before?
# h.mpd = currentMCMC$P[1,"h"]
Nats.mpd = currentRes$N
ut.mpd = currentRes$B$U[-length(currentRes$B$U)]  
                                  # remove final NA for 2011
Bt.mpd = currentRes$B$SB
B0.mpd = Bt.mpd[1]
Vt.mpd = currentRes$B$V
logRecDev.mpd = currentRes$Dev$Annual


# From Rowan's extra function, to give the mpd's:
R0.mpd = currentRes$extra$parameters$R0
M1.mpd = currentRes$extra$parameters$M1[1]
M2.mpd = currentRes$extra$parameters$M1[2]
h.mpd = currentRes$extra$parameters$h
qvec.mpd = exp(currentRes$extra$parameters$log_qsurvey) # surveys

# CPUE:
qCPUE.mpd = exp(currentRes$extra$parameters$log_qCPUE)  # q for CPUE
betaCPUE.mpd = exp(currentRes$extra$parameters$log_BetaCPUE)

# survey selectivities:
muvec.mpd = currentRes$extra$parameters$surveySfull    
deltavec.mpd = currentRes$extra$parameters$survey_SfullDelta 
logvvec.mpd = currentRes$extra$parameters$log_surveyvarL

# commercial selectivities:
mu6.mpd = currentRes$extra$parameters$Sfullest    # comm mu
delta6.mpd = currentRes$extra$parameters$SfullDelta
logv6.mpd = currentRes$extra$parameters$log_varLest



# From Rowan's extra function, to give the priors, not all are _prior
R0.prior = currentRes$extra$priors$R0_prior
M1.prior = currentRes$extra$priors$M1_prior[1,] 
M2.prior = currentRes$extra$priors$M1_prior[2,]
h.prior = currentRes$extra$priors$h_prior
logqvec.prior = currentRes$extra$priors$log_qsurvey_prior# surveys, matrix

# CPUE:
logqCPUE.prior = currentRes$extra$priors$log_qCPUE  # q for CPUE
#    moved next one to above to use as switch when changing names
#    of MCMC posteriors.
# logbetaCPUE.prior = currentRes$extra$priors$log_BetaCPUE

# survey selectivities (all matrices):
muvec.prior = currentRes$extra$priors$surveySfull_prior
deltavec.prior = currentRes$extra$priors$p_surveySfulldelta 
logvvec.prior = currentRes$extra$priors$log_surveyvarL_prior

# commercial selectivities:
mu6.prior = currentRes$extra$priors$p_Sfullest    # comm mu
delta6.prior = currentRes$extra$priors$p_Sfulldelta
logv6.prior = currentRes$extra$priors$log_varLest_prior


# To make a list of priors to use in plotDensPOPParsPrior().
#  For ymr for now not automating, as short on time.
# Might need this to do automatically:
# sapply(currentRes$extra$priors, function(x) {if(is.array(x)) return(x[,1]) else return(x[1])})

# DID THIS IN plotDensPOPparsPrior.r to get working, then copy here:
priorDistList = list()     # Need a list to be functions to go into
priorBoundsList = list()      # panel.curve
                           # And need bounds for panel.curve, which
                           #  are a bit fiddly from Rowan's
                           #  currentRes$extra$priors  as order is
                           #  different and q's are grouped, so
                           #  panel.number() can't be used. Should
                           #  tidy all this up afterwards.
  i = 1    # i to increment so get List of correct length to use
         #  panel.number() in panel.curve

  priorDistList[[i]] = function(x) 
      { dunif(x, min = R0.prior[2], max = R0.prior[3])
      }
  priorBoundsList[[i]] = c( R0.prior[2], R0.prior[3])
  i = i+1

  if(length(currentMCMC$P$M_1) > 0)    # Then estimating M:
    {
      priorDistList[[i]] = function(x) 
        { dnorm(x, mean=M1.prior[5], sd=M1.prior[6])
        }
      priorBoundsList[[i]] = c( M1.prior[2], M1.prior[3])
      i = i+1
    
      priorDistList[[i]] = function(x) 
        { dnorm(x, mean=M2.prior[5], sd=M2.prior[6])
        }
      priorBoundsList[[i]] = c( M2.prior[2], M2.prior[3])
      i = i+1
    }

    # For h, pars in Awatea input are 4.574, 2.212, checking these
    #  are the shape1, shape2 parameters, which they are because
    #  these give the same prior for h as we had for POP:
    # mean(rbeta(100000, 4.574, 2.212))
    # [1] 0.674526
    # sd(rbeta(100000, 4.574, 2.212))
    # 0.1680018
  priorDistList[[i]] = function(x) 
      { dbeta(x, h.prior[5], h.prior[6])
      }
  priorBoundsList[[i]] = c( h.prior[2], h.prior[3])
  i = i+1

    # q1
  priorDistList[[i]] = function(q)
       { (q*( logqvec.prior[1,3] - logqvec.prior[1,2]))^(-1)
       }
        # log q uniform between a and b, then pdf for q is
        #  1/(q (b-a)) between exp(a) and exp(b)
        #  assuming don't need to plot outside of bounds. This
        #  didn't work as just returned single NA for a vector
        #  which is what panel.curve sends.
      #if(x > exp(logqvec.prior[1,2]) && x < exp(logqvec.prior[1,3]))
      #    {
      #      y = (x*( logqvec.prior[1,3] - logqvec.prior[1,2]))^(-1)
      #    } else
      #    { y = NA
      #    }
      #  return(y)  
  priorBoundsList[[i]] = c( exp(logqvec.prior[1,2]),
      exp(logqvec.prior[1,3]))   # Need to exp as not plotting on log
  i = i+1

    # q2     Have to increment the [[]], and the logqvec.prior[*,]
  priorDistList[[i]] = function(x)
       { (x*( logqvec.prior[2,3] - logqvec.prior[2,2]))^(-1)
       }
  priorBoundsList[[i]] = c( exp(logqvec.prior[2,2]),
      exp(logqvec.prior[2,3]))   # Need to exp as not plotting on log
  i = i+1

    # q3     Have to increment the [[]], and the logqvec.prior[*,]
  priorDistList[[i]] = function(x)
       { (x*( logqvec.prior[3,3] - logqvec.prior[3,2]))^(-1)
       }
  priorBoundsList[[i]] = c( exp(logqvec.prior[3,2]),
      exp(logqvec.prior[3,3]))   # Need to exp as not plotting on log
  i = i+1

    # q4     Have to increment the [[]], and the logqvec.prior[*,]
  priorDistList[[i]] = function(x)
       { (x*( logqvec.prior[4,3] - logqvec.prior[4,2]))^(-1)
       }
  priorBoundsList[[i]] = c( exp(logqvec.prior[4,2]),
      exp(logqvec.prior[4,3]))   # Need to exp as not plotting on log
  i = i+1

    # q5     Have to increment the [[]], and the logqvec.prior[*,]
  priorDistList[[i]] = function(x)
       { (x*( logqvec.prior[5,3] - logqvec.prior[5,2]))^(-1)
       }
  priorBoundsList[[i]] = c( exp(logqvec.prior[5,2]),
      exp(logqvec.prior[5,3]))   # Need to exp as not plotting on log
  i = i+1

    # mu1, row 1 of muvec.prior
  priorDistList[[i]] = function(x) 
      { dnorm(x, mean=muvec.prior[1,5], sd=muvec.prior[1,6])
      }
  priorBoundsList[[i]] = c( muvec.prior[1,2], muvec.prior[1,3])
i = i+1

    # mu2, row 2 of muvec.prior
  priorDistList[[i]] = function(x) 
      { dnorm(x, mean=muvec.prior[2,5], sd=muvec.prior[2,6])
      }
  priorBoundsList[[i]] = c( muvec.prior[2,2], muvec.prior[2,3])
  i = i+1

    # mu3, mu4, mu5 fixed.

    # mu6
  priorDistList[[i]] = function(x) 
      { dnorm(x, mean=mu6.prior[5], sd=mu6.prior[6])
      }
  priorBoundsList[[i]] = c( mu6.prior[2], mu6.prior[3])
  i = i+1

    # Delta1, row1 of deltavec.prior
  priorDistList[[i]] = function(x) 
      { dnorm(x, mean=deltavec.prior[1,5], sd=deltavec.prior[1,6])
      }
  priorBoundsList[[i]]= c(deltavec.prior[1,2],deltavec.prior[1,3])
  i = i+1

    # Delta2, row2 of deltavec.prior
  priorDistList[[i]] = function(x) 
      { dnorm(x, mean=deltavec.prior[2,5], sd=deltavec.prior[2,6])
      }
  priorBoundsList[[i]]= c(deltavec.prior[2,2],deltavec.prior[2,3])
  i = i+1

    # Delta6, delta6.prior
  priorDistList[[i]] = function(x) 
      { dnorm(x, mean=delta6.prior[5], sd=delta6.prior[6])
      }
  priorBoundsList[[i]]= c(delta6.prior[2],delta6.prior[3])
  i = i+1

    # log var1L, row1 of logvvec.prior
  priorDistList[[i]] = function(x) 
      { dnorm(x, mean=logvvec.prior[1,5], sd=logvvec.prior[1,6])
      }
  priorBoundsList[[i]]= c(logvvec.prior[1,2],logvvec.prior[1,3])
  i = i+1

    # log var2L, row2 of logvvec.prior
  priorDistList[[i]] = function(x) 
      { dnorm(x, mean=logvvec.prior[2,5], sd=logvvec.prior[2,6])
      }
  priorBoundsList[[i]]= c(logvvec.prior[2,2],logvvec.prior[2,3])
  i = i+1

    # log var6L, logv6.prior
  priorDistList[[i]] = function(x) 
      { dnorm(x, mean=logv6.prior[5], sd=logv6.prior[6])
      }
  priorBoundsList[[i]]= c(logv6.prior[2],logv6.prior[3])





# Moved from above, as now have currentMCMC$U calcs
# mainMenu() # don't want menu, just choose which:
# plt.mpdGraphs( currentRes, save=TRUE )
      #some now more correctly use MCMC results [don't think so now]
# plt.idx( currentRes$Survey,main="Survey Indices") # wasn't called 
#  in plt.mpdGraphs. Doing it here spits out SD of standardised 
#  residuals also. May be useful for iterative reweighting?
plt.mcmcGraphs( currentMCMC, currentProj, save=TRUE, 
               xlimrec=c(0,50000) ) 
              # xlimrec is x axis for recruitment posteriors, setting
              #  here for YMR.
close.allWin()


# function to use for priors in MPD table. Must read in a vector of 
#  length, and outputs it in the format for the table.
ptab = function(xx) 
  { print(paste(c(xx[1], " & [", xx[2], ",", xx[3], "] & ", 
          xx[4], " & [", xx[5], ",", xx[6], "] & ", xx[7]),
          sep="", collapse="")) 
  }
qtab = function(xx.MCMC, dig=0)     # dig is number of dec places
  { print(paste( c( round(quantile(xx.MCMC, 0.05), digits=dig), 
         " & ", round(quantile(xx.MCMC, 0.50), digits=dig), 
         " & ", round(quantile(xx.MCMC, 0.95), digits=dig)), 
         sep="", collapse=""))
  }  

# not saving for YMR for now (don't have all these variables, though
#  just MPDs so don't need MCMC output).  [These were from MCMC's]
# save(A, T, Ct, selgeqComm, mat, M1, M2, Rt, R0.mpd, h.mpd, Nats.mpd, ut.mpd,  Bt.mpd, B0.mpd, Vt.mpd, logRecDev.mpd, file="run23values.RData")
 # 
# save.image(file="run23all.RData")

# See popScape2.r for pairs plots, from:
# Copy and run this for pairs plots        to
# text(currentRes$B$SB, currentRes$B$U, 1:72)

# For fits:
#> windows(); plotBubbles(yy, dnam=TRUE, size=0.08, hide0=TRUE)
#>

# Also want to do catches and biomass predictions
# plot(years[-length(years)], Ct)
# > plot(years, Bt.mpd, ylim=c(0,200000))
# > plot(years, Bt.mpd, ylim=c(0,120000))
# > plot(years[-length(years)], Ct)
@ 

% Comment out table parest for now (Priors and MPD estimates - see
%  ymrrun-master.Snw), though use that as template to make a table
% of posterior statistics

% Then find and replace run *** to Estimate M for the write up.

\ymrfig{traceParams}{MCMC traces for the primary estimated parametersfor run \Sexpr{model.name}. Grey lines show the 1000 samples for each parameter, solid lines show the cumulative median (up to that sample), and dashed lines show the cumulative 2.5 and 97.5 quantiles.  Red circles are the MPD estimates. Subscripts 1 to 5 are for surveys: GIG historical, QCS synoptic, QCS shrimp, WCHQ synoptic and WCVI synoptic. Subscript 6 is the commercial fishery.}   % for the base run "Estimate M \& h".

\ymrfig{splitChain}{Diagnostic plot for run \Sexpr{model.name}, obtained by dividing the MCMC chain of 1000 MCMC samples into three segments, and overplotting the cumulative distributions of the first segment (green), second segment (red) and final segment (blue).}
% overplotting the cumulative distributions, removing the first 100, then plotting the cumulative distributions for samples 101-400 (green), 301-700 (red) and 701-1000 (blue). }

\ymrfig{pairs1}{Pairs plot of 1000 MCMC samples for first six parameters for run \Sexpr{model.name}.}

\ymrfig{pairs2}{Pairs plot of 1000 MCMC samples for second six parameters for run \Sexpr{model.name}.}

\ymrfig{pairs3}{Pairs plot of 1000 MCMC samples for final parameters for run \Sexpr{model.name}.}



\ymrfig{traceBiomass}{MCMC traces for female spawning biomass estimates at five-year intervals for run \Sexpr{model.name}.  Note that vertical scales are different for each plot (to show convergence of the MCMC chain, rather than absolute differences in annual values). Grey lines show the 1000 samples for each parameter, solid lines show the cumulative  median (up to that sample), and dashed lines show the cumulative  2.5 and 97.5 quantiles.  Red circles are the MPD estimates.}

\ymrfig{traceRecruits}{MCMC traces for recruitment estimates at five-year intervals for run \Sexpr{model.name}. Note that vertical scales are different for each plot (to show convergence of the MCMC chain, rather than absolute differences in annual recruitment). Grey lines show the 1000 samples for each parameter, solid lines show the cumulative  median (up to that sample), and dashed lines show the cumulative  2.5 and 97.5 quantiles.  Red circles are the MPD estimates.}

\ymrfig{pdfParameters}{Marginal posterior densities (thick black curves) and prior density functions (thin blue curves) for the estimated parameters for run \Sexpr{model.name}. Vertical lines represent the 2.5, 50 and 97.5 percentiles, and red filled circles are the MPD estimates. For $R_0$ the prior is a uniform distribution on the range [\Sexpr{R0.prior[2]}, \Sexpr{R0.prior[3]}], and is at too low a value to show up on the graph. The priors for $q_g$ are uniform on a log-scale, and so the probability density function is $1/(x(b-a))$ on a linear scale (where $a=-5$ and $b=12$ are the bounds on the log scale), such that half of the weight of the prior distribution lies $>0.03$ [**for the parameters used in YMR], which is not obvious from the graphs. *** Parameter values are loaded automatically from the Awatea output, but if the distributions change type or parameters are fixed/estimated (except M's) then need to manually change priorDistList[[]] in ymrScape.r.}

\clearpage

\ymrfig{selectivityMCMC}{**** MCMC selectivity figure will go here, haven't calculated yet (started in {\tt plotSelMCMC.r}) but leave for now to get writing. This is just a placeholder ******}

\ymrfig{pdfBiomass1}{Marginal posterior densities for beginning year female spawning biomass (1000 tonnes) for years 1940-1963 for run \Sexpr{model.name}. Horizontal axes are all to same scale. Note that vertical axes are not to the same scale, but each is scaled to the peak of the density; with the area under each curve integrating to 1.0. Vertical lines are 2.5, 50 and 97.5 percentiles, and filled red circle indicates MPD value.}

\ymrfig{pdfBiomass2}{As for Figure \ref{fig:pdfBiomass1} for years 1964-1987.}

\ymrfig{pdfBiomass3}{As for Figure \ref{fig:pdfBiomass1} for years 1988-2011.}

\ymrfig{pdfRecruitment1}{Marginal posterior densities for recruitment for years 1940-1963 for run \Sexpr{model.name}. Horizontal axes are all to same scale, such that large recruitments in certain large years can be seen. Note that vertical axes are not to the same scale, but each is scaled to the peak of the density; areas under each curve will integrate to 1.0. Vertical lines are 2.5, 50 and 97.5 percentiles, and filled red circle indicates MPD value. }

\ymrfig{pdfRecruitment2}{As for Figure \ref{fig:pdfRecruitment1} for years 1964-1987.}

\ymrfig{pdfRecruitment3}{As for Figure \ref{fig:pdfRecruitment1} for years 1988-2011.}

\ymrfig{recruitsMCMC}{Marginal posterior distribution of recruitment in 1000's of age 1 fish plotted over time for run \Sexpr{model.name}. The boxes give the 2.5, 25, 50, 75 and 97.5 percentiles from the MCMC results.}

\ymrfig{exploitMCMC}{Marginal posterior distribution of exploitation rate plotted over time for run \Sexpr{model.name}. The boxes give the 2.5, 25, 50, 75 and 97.5 percentiles from the MCMC results.}

\ymrfig{VBcatch}{Vulnerable biomass (boxplots) and commercial catch (vertical bars) over time for run \Sexpr{model.name}. Boxplots show the 2.5, 25, 50, 75 and 97.5 percentiles from the MCMC results. Catch is shown to compare its magnitude to the estimated vulnerable biomass.}

\ymrfig{BVBnorm}{Changes in $B_t / B_0$ and $V_t / V_0$ (spawning and vulnerable biomass relative to virgin levels) over time for run \Sexpr{model.name}, shown as the medians of the MCMC posteriors.}

\clearpage 

\ymrfig{snail}{Trace through time of the medians of the ratios $B_t / B_\mathrm{MSY}$ (the spawning biomass in year $t$ relative to $B_\mathrm{MSY}$) and $u_t / u_\mathrm{MSY}$ (the exploitation rate in year $t$ relative to $u_\mathrm{MSY}$) for run \Sexpr{model.name}. Blue filled circle is the starting year (1940). Years then proceed from light grey through to dark grey with the final year (2010) as a filled red circle, and the red lines represent the 10\% and 90\% percentiles of the posterior distributions for the final year. Vertical grey lines indicate the provisional limit and upper stock reference points of 0.4$B_\mathrm{MSY}$ and 0.8$B_\mathrm{MSY}$, and horizontal grey line indicates $u_\mathrm{MSY}$.}

\ymrfig{Bproj}{Projected biomass under different constant catch strategies for run \Sexpr{model.name}~(boxplots show the 2.5, 25, 50, 75 and 97.5 percentiles from the MCMC results). For each of the 1000 samples from the MCMC posterior, the model was run forward in time (red) with a constant catch, and recruitment was simulated from the stock-recruitment function with lognormal error (see equation F.24). For reference, the average catch over the last five years (2006-2010) is 1442~t.}

\clearpage     % to get tables at end

\begin{table}[tp]
\centering
\caption{\label{tab:MCMCpar} 
Summary statistics of MCMC results for estimated parameters for run \Sexpr{model.name}. Parameters are defined in Appendix F. Except for $M_1$ and $M_2$, subscripts 1 to 5 correspond to the fishery-independent surveys, and subscript 6 to the commercial fishery.}
\begin{tabular}{lrrr} 
\hline
Parameter & \multicolumn{3}{c}{Percentile}\\
\cline{2-4}
 & 5\% & 50\% & 95\% \\
\hline 
$R_0$    & \Sexpr{qtab(currentMCMC$P$R_0)} \\
$M _ 1$  & \Sexpr{ if(length(currentMCMC$P$M_1) > 0) qtab(currentMCMC$P$M_1,dig=4) else  print(paste( "- & - & -", collapse = "")) } \\
$M _ 2$  & \Sexpr{ if(length(currentMCMC$P$M_2) > 0) qtab(currentMCMC$P$M_2,dig=4)  else  print(paste( "- & - & -", collapse = "")) } \\
$h$        & \Sexpr{qtab(currentMCMC$P$h, dig=3)} \\
$q_1$      & \Sexpr{qtab(currentMCMC$P$q_1, dig=5)} \\
$q_2$      & \Sexpr{qtab(currentMCMC$P$q_2, dig=5)} \\
$q_3$      & \Sexpr{qtab(currentMCMC$P$q_3, dig=5)} \\
$q_4$      & \Sexpr{qtab(currentMCMC$P$q_4, dig=5)} \\
$q_5$      & \Sexpr{qtab(currentMCMC$P$q_5, dig=5)} \\
$\mu_1$    & \Sexpr{qtab(currentMCMC$P$mu_1, dig=1)} \\
$\mu_2$    & \Sexpr{qtab(currentMCMC$P$mu_2, dig=1)} \\
$\mu_6$    & \Sexpr{qtab(currentMCMC$P$mu_6, dig=1)} \\
$\Delta_1$ & \Sexpr{qtab(currentMCMC$P$Delta_1, dig=2)} \\
$\Delta_2$ & \Sexpr{qtab(currentMCMC$P$Delta_2, dig=2)} \\ 
$\Delta_6$ & \Sexpr{qtab(currentMCMC$P$Delta_6, dig=2)} \\
$\log v_{1L}$  & \Sexpr{qtab(currentMCMC$P$"log v_1L", dig=2)} \\
$\log v_{2L}$  & \Sexpr{qtab(currentMCMC$P$"log v_2L", dig=2)} \\
$\log v_{6L}$  & \Sexpr{qtab(currentMCMC$P$"log v_6L", dig=2)} \\
\hline
\end{tabular}	
\end{table}



\begin{table}[tp]
\centering
\caption{\label{tab:MCMCderived} MCMC-derived quantities for run \Sexpr{model.name}, from each sample of the MCMC posterior. A maximum exploitation rate $u_{max}$ is calculated for each sample as the maximum exploitation rate from 1940-2010. For reference, the average catch over the last five years (2006-2010) is 1442~t.}
\medskip
\begin{tabular}{lrrr} 
\hline
Value & \multicolumn{3}{c}{Percentile}\\
\cline{2-4}
 & 5\% & 50\% & 95\% \\
\hline 
 & & & \\
& \multicolumn{3}{c}{From model output}\\
$B_0$                  & \Sexpr{qtab(B0.MCMC)} \\
$V_0$                  & \Sexpr{qtab(VB0.MCMC)} \\
$B_{2011}$             & \Sexpr{qtab(B2011.MCMC)} \\
$V_{2011}$             & \Sexpr{qtab(VB2011.MCMC)} \\

$B_{2011} / B_0$       & \Sexpr{qtab(B2011.MCMC / B0.MCMC, dig=3)} \\
$V_{2011} / V_0$     & \Sexpr{qtab(VB2011.MCMC / VB0.MCMC, dig=3)} \\

$u_{2010}$             & \Sexpr{qtab(u2010.MCMC, dig=3)} \\
$u_\mathrm{max}$       & \Sexpr{qtab(umax.MCMC, dig=3)} \\
\hline
 & & & \\
& \multicolumn{3}{c}{MSY-based quantities}\\
$0.4 B_\mathrm{MSY}$   &  \Sexpr{qtab(0.4*Bmsy.MCMC)} \\
$0.8 B_\mathrm{MSY}$   &  \Sexpr{qtab(0.8*Bmsy.MCMC)} \\
$B_\mathrm{MSY}$       &  \Sexpr{qtab(Bmsy.MCMC)} \\
$B_\mathrm{MSY} / B_0$ &  \Sexpr{qtab(Bmsy.MCMC / B0.MCMC, dig=3)} \\
$B_{2011} / B_\mathrm{MSY}$ & \Sexpr{qtab(B2011.MCMC / Bmsy.MCMC, dig=3)} \\

$\mathrm{MSY}$                    & \Sexpr{qtab(msy.MCMC)} \\
$u_\mathrm{MSY}$       & \Sexpr{qtab(umsy.MCMC, dig=3)} \\
$u_{2010} / u_\mathrm{MSY}$ & \Sexpr{qtab(u2010.MCMC / umsy.MCMC, dig=3)} \\

$V_\mathrm{MSY}$       & \Sexpr{qtab(VBmsy.MCMC)} \\
$V_\mathrm{MSY} / V_0$ & \Sexpr{qtab(VBmsy.MCMC / VB0.MCMC, dig=3)} \\
\hline
\end{tabular}	
\end{table}


<<results=tex, echo=FALSE>>=
# xtable(matrix( c( hbigeye100$counts), ncol=4, byrow=TRUE), digits = 0, caption="Counts for 1-100, showing every 4th seems to be higher, with every 8th being way higher.")
print(xtable(refProbs5$LRP, caption="Decision table concerning the limit reference point $0.4 \\Bmsy$ for 1-5 year projections for run MODEL.NAME for a range of constant catch strategies (in tonnes). Values are P$(B_t > 0.4 \\Bmsy)$, i.e.~the probability of the spawning biomass at the start of year $t$ being greater than the limit reference point. The probabilities are based on the MCMC posterior distributions of $B_t$ and $\\Bmsy$. [Table done automatically, can add extra details (as for POP) for final write up.]", label="tab:LRP5", digits=3), caption.placement="top") 
# it didn't like \Sexpr in caption=""

print(xtable(refProbs5$URP, caption="Decision table for the upper reference point $0.8 \\Bmsy$ for 1-5 year projections for run MODEL.NAME, such that values are P$(B_t > 0.8 \\Bmsy)$.", label="tab:URP5", digits=3), caption.placement="top")

# print(xtable(refProbs5$Bmsy, caption="Decision table for MSY for 1-5 year projections for run MODEL.NAME, such that values are P$(B_t > \\Bmsy)$.", label="tab:Bmsy5", digits=3), caption.placement="top")

print(xtable(refProbsB05$B00.2, caption="Decision table for the alternative limit reference point $0.2 B_0$ for 1-5 year projections for run MODEL.NAME, such that values are P$(B_t > 0.2 B_0)$.", label="tab:B00.2.5yr", digits=3), caption.placement="top")

print(xtable(refProbsB05$B00.4, caption="Decision table for the alternative upper reference point $0.4 B_0$ for 1-5 year projections for run MODEL.NAME, such that values are P$(B_t > 0.4 B_0)$.", label="tab:B00.4.5yr", digits=3), caption.placement="top")

print(xtable(refProbsB05$B00.5, caption="Decision table for reference point $0.5 B_0$ for 1-5 year projections for run MODEL.NAME, such that values are P$(B_t > 0.5 B_0)$.", label="tab:B00.5.5yr", digits=3), caption.placement="top")

print(xtable(refProbsB05$B00.7, caption="Decision table for reference point $0.7 B_0$ for 1-5 year projections for run MODEL.NAME, such that values are P$(B_t > 0.7 B_0)$.", label="tab:B00.7.5yr", digits=3), caption.placement="top")


print(xtable(refProbs20$LRP, caption="Decision table for the lower reference point $0.4 \\Bmsy$ for every 5th year of 20-year projections for run MODEL.NAME, such that values are P$(B_t > 0.4 \\Bmsy)$.", label="tab:LRP20", digits=3), caption.placement="top")

print(xtable(refProbs20$URP, caption="Decision table for the upper reference point $0.8 \\Bmsy$ for every 5th year of 20-year projections for run MODEL.NAME, such that values are P$(B_t > 0.8 \\Bmsy)$.", label="tab:URP20", digits=3), caption.placement="top")

print(xtable(refProbs20$Bmsy, caption="Decision table for $\\Bmsy$ for every 5th year of 20-year projections for run MODEL.NAME, such that values are P$(B_t > \\Bmsy)$.", label="tab:Bmsy20", digits=3), caption.placement="top")

@ 



\end{document}

% CUT HERE - if delete then correct one at end of file

\ymrfig{catch}{Commercial catch data}

<<bubbleplots, results=HIDE, echo=FALSE>>=
# Should redo as a function in scape program, but quicker for now:
CAcObsFem = matrix(currentRes$CAc$Obs[is.element(currentRes$CAc$Sex,
  "Female")], nrow=length(ages))  
yrCAc = sort(unique(currentRes$CAc$Year))
dimnames(CAcObsFem)[[1]] = ages
dimnames(CAcObsFem)[[2]] = yrCAc

fig.name = paste(model.name, "bubFem", sep="")
postscript("CAcObsFem.eps", horizontal=FALSE, paper="special", height = 7, width = 6)  # Couldn't properly change figure
                                  #  size without doing this
plotBubbles(CAcObsFem, dnam=TRUE, size=0.10, hide0=TRUE, 
            main="Females")
# abline(a=-1976, b=1)   # to follow cohort 
dev.off()

CAcObsMale = matrix(currentRes$CAc$Obs[is.element(currentRes$CAc$Sex,
  "Male")], nrow=length(ages))  
dimnames(CAcObsMale)[[1]] = ages
dimnames(CAcObsMale)[[2]] = yrCAc

postscript("CAcObsMale.eps", horizontal=FALSE, paper="special", height = 7, width = 6)
plotBubbles(CAcObsMale, dnam=TRUE, size=0.10, hide0=TRUE, 
            main="Males")
# abline(a=-1976, b=1)   # to follow cohort 
dev.off()


# And now for Fit to data
CAcFitFem = matrix(currentRes$CAc$Fit[is.element(currentRes$CAc$Sex,
  "Female")], nrow=length(ages))  
dimnames(CAcFitFem)[[1]] = ages
dimnames(CAcFitFem)[[2]] = yrCAc

fig.name = paste(model.name, "bubFem", sep="")
postscript("CAcFitFem.eps", horizontal=FALSE, paper="special", height = 7, width = 6)  # Couldn't properly change figure
                                  #  size without doing this
plotBubbles(CAcFitFem, dnam=TRUE, size=0.10, hide0=TRUE, 
            main="Females")
# abline(a=-1976, b=1)   # to follow cohort 
dev.off()

CAcFitMale = matrix(currentRes$CAc$Fit[is.element(currentRes$CAc$Sex,
  "Male")], nrow=length(ages))  
dimnames(CAcFitMale)[[1]] = ages
dimnames(CAcFitMale)[[2]] = yrCAc

postscript("CAcFitMale.eps", horizontal=FALSE, paper="special", height = 7, width = 6)
plotBubbles(CAcFitMale, dnam=TRUE, size=0.10, hide0=TRUE, 
            main="Males")
# abline(a=-1976, b=1)   # to follow cohort 
dev.off()

@

\ymrfig{CAcObsFem}{Commercial catch-at-age data for females}

\ymrfig{CAcObsMale}{Commercial catch-at-age data for males}

\ymrfig{CAcFitFem}{Commercial catch-at-age model output for females}

\ymrfig{CAcFitMale}{Commercial catch-at-age model output for males}

% \section{Figures for MPD values}

\ymrfig{survIndSer}{Fits to the five fishery independent surveys.}

\ymrfig{survIndSer2}{Fits to the five fishery independent surveys, same year axis for all time series.}

<<CPUEfig, results=HIDE, echo=FALSE>>=    # Crude for now
postscript("CPUEfit.eps", horizontal=FALSE, paper="special", height = 7, width = 6)
zobs = !is.na(currentRes$CPUE$Obs)
xlim = range(currentRes$CPUE$Year[zobs]); ylim = range(c(currentRes$CPUE$Obs[zobs],currentRes$CPUE$Fit[zobs]))
plot(currentRes$CPUE$Year, currentRes$CPUE$Obs, xlim=xlim, ylim=ylim, type="n", xlab="Year",ylab="CPUE: Observed & Fit")
	series = unique(currentRes$CPUE$Series); nseries = length(series)
	for (i in 1:nseries) {
		ii = series[i]; z = is.element(currentRes$CPUE$Series,ii)
		points(currentRes$CPUE$Year[z], currentRes$CPUE$Obs[z], pch=21, bg=i+1, cex=1.2)
		lines(currentRes$CPUE$Year[z], currentRes$CPUE$Fit[z], col=i+1, lwd=2) }
dev.off()
@ 

\ymrfig{CPUEser}{CPUE index series, 95\% error bars are based on lognormal assumption (think about more).}

\ymrfig{CPUEfit}{Crude plot of CPUE index series, without error bars.}

\ymrfig{ageCommFemale1}{Observed and predicted proportions-at-age for females, commercial data (1977-1995). Note that years are not consecutive.}

\ymrfig{ageCommMale1}{Observed and predicted proportions-at-age for males, commercial data (1977-1995). Note that years are not consecutive.}

%\ymrfig{ageCommFemale2}{Observed and predicted proportions-at-age for females, commercial data (1991-1995). Note that years are not consecutive.}

%\ymrfig{ageCommMale2}{Observed and predicted proportions-at-age for males, commercial data (1991-1995). Note that years are not consecutive.}

%\ymrfig{ageCommFemale3}{Observed and predicted proportions-at-age for females, commercial data (1996-2010). Note that years are not consecutive.}

%\ymrfig{ageCommMale3}{Observed and predicted proportions-at-age for males, commercial data (1996-2010). Note that years are not consecutive.}

\clearpage 

\twofig{ageSurvGIGFemale1}{ageSurvGIGMale1}{Observed and predicted proportions-at-age for Goose Island Gully survey.}

\twofig{ageSurvQCSsynFemale1}{ageSurvQCSsynMale1}{Observed and predicted proportions-at-age for Queen Charlotte Sound synoptic survey.}

\ymrfig{Bt}{Spawning biomass (mature females) over time (MPD)}

\begin{figure}[htp]
\centering
\begin{tabular}{c}
\epsfbox{BtB0.eps} 
\vspace{-20mm} \\
\epsfbox{catchSmall.eps}
\end{tabular}
\caption{Spawning biomass (mature females) relative to virgin level, $B_t / B_0$, and commercial catch.}
\label{fig:BtB0}
\end{figure}

\ymrfig{exploit}{Exploitation rate (MPD) over time}

\ymrfig{recruits}{Recruitment rate (MPD) over time, in 1000's of age 1 fish.}

\ymrfig{selectivity}{Selectivities for commercial catch and surveys (only first two surveys are currently estimated, just following on from POP).}

% \section{Residuals associated with MPD fits}

\ymrfig{survGIG}{Residuals for fit to Goose Island Gully historical survey series}

\ymrfig{survQCSsyn}{Residuals for fit to Queen Charlotte Sound synoptic survey series}

\ymrfig{survQCSshr}{Residuals for fit to Queen Charlotte Sound shrimp survey series}

\ymrfig{survWCHG}{Residuals for fit to West Coast Haida Gwai survey series}

\ymrfig{survWCVI}{Residuals for fit to West Coast Vancouver Island survey series}


\ymrfig{commAgeResids}{Residuals for fit to commercial age data}

\ymrfig{survAgeResidsSer1}{Residuals for fit to Goose Island Gully survey series age data}

\ymrfig{survAgeResidsSer2}{Residuals for fit to QCS synoptic survey series age data}

\end{document}

% C*UT HERE    - remove * if remove the one above
